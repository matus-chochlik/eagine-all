<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="author" content="Matus Chochlik"/>
<meta name="copyright" content="Copyright 2015-2022 Matus Chochlik"/>
<meta name="keywords" content="C++ EGL OpenGL OpenAL Graphics Rendering"/>
<meta name="description" content="C++ wrapper for rendering C APIs"/>
<title>Type utilities</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="eagine.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="eagine-frame">
<div id="eagine-bar">
	<div id="eagine-top">
	<div id="eagine-top-content">
		<div id="eagine-caption">
	   		<div id="eagine-brief">
					<span id="eagine-name">EAGine&#160;</span>
					<span id="eagine-version">(0.87.0)</span> a C++ wrapper for rendering APIs
				</div>
		</div>
		<hr/>
	</div>
	</div>
	<div id="eagine-icon">
		<a href="http://oglplus.org/"><img src="../oglplus-circular.png"/></a>
	</div>
</div>
<div id="eagine-content">
<div id="top">
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Type utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1memory_1_1has__span__size__member.html">eagine::memory::has_span_size_member&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class detecting if type T has x.size() member function.  <a href="structeagine_1_1memory_1_1has__span__size__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1memory_1_1has__span__data__member.html">eagine::memory::has_span_data_member&lt; T, E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class detecting if type T has x.data() member function.  <a href="structeagine_1_1memory_1_1has__span__data__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">eagine::memory::basic_span&lt; ValueType, Pointer, SizeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning view of a contiguous range of memory with ValueType elements.  <a href="classeagine_1_1memory_1_1basic__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__chunk__span.html">eagine::memory::basic_chunk_span&lt; ValueType, Pointer, SizeType, chunkSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning view of a contiguous range of memory with ValueType elements.  <a href="classeagine_1_1memory_1_1basic__chunk__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1anything.html">eagine::anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that can by constructed from single argument of any other type.  <a href="structeagine_1_1anything.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1nothing__t.html">eagine::nothing_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing "none" / "nothing" values.  <a href="structeagine_1_1nothing__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1interface.html">eagine::interface&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for abstract interfaces, implements common functionality.  <a href="classeagine_1_1interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1abstract.html">eagine::abstract&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for polymorphic classes, implements common functionality.  <a href="classeagine_1_1abstract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1main__ctx__log__backend__getter.html">eagine::main_ctx_log_backend_getter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used in the implementation of logging in main context object.  <a href="classeagine_1_1main__ctx__log__backend__getter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1protected__member.html">eagine::protected_member&lt; T, Selector &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class holding a single tagged data member.  <a href="classeagine_1_1protected__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__value__proxy.html">eagine::biteset_value_proxy&lt; BiS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class that can be used to access elements in a biteset.  <a href="classeagine_1_1biteset__value__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__value__proxy__base.html">eagine::biteset_value_proxy_base&lt; BiS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for biteset value proxy.  <a href="classeagine_1_1biteset__value__proxy__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__value__proxy_3_01const_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html">eagine::biteset_value_proxy&lt; const biteset&lt; N, B, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of biteset proxy for const biteset values.  <a href="classeagine_1_1biteset__value__proxy_3_01const_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__value__proxy_3_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html">eagine::biteset_value_proxy&lt; biteset&lt; N, B, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of biteset proxy for mutable biteset values.  <a href="classeagine_1_1biteset__value__proxy_3_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__iterator_3_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html">eagine::biteset_iterator&lt; biteset&lt; N, B, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type for biteset.  <a href="classeagine_1_1biteset__iterator_3_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset.html">eagine::biteset&lt; N, B, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of unsigned integer values with specified number bits.  <a href="classeagine_1_1biteset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1bitfield.html">eagine::bitfield&lt; Bit &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for manipulating and testing a group of enumeration-based bits.  <a href="classeagine_1_1bitfield.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1byteset.html">eagine::byteset&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing a sequence of bytes converting them to and from unsigned integer.  <a href="classeagine_1_1byteset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1double__buffer.html">eagine::double_buffer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class holding two instances of type <code>T</code> and allows to switch them.  <a href="classeagine_1_1double__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html">eagine::c_api::key_value_list_element&lt; Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single key/value pair for a key/value list.  <a href="structeagine_1_1c__api_1_1key__value__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1c__api_1_1key__value__list.html">eagine::c_api::key_value_list&lt; Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for classes wrapping static key/value typically attribute lists.  <a href="classeagine_1_1c__api_1_1key__value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1basic__iterable__type.html">eagine::basic_iterable_type&lt; T, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template used in implementation of some iterators.  <a href="classeagine_1_1basic__iterable__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1basic__selfref__iterator.html">eagine::basic_selfref_iterator&lt; T, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator referencing the wrapped iterable type.  <a href="classeagine_1_1basic__selfref__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1selfref__iterator.html">eagine::selfref_iterator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of <a class="el" href="classeagine_1_1basic__selfref__iterator.html" title="Iterator referencing the wrapped iterable type.">basic_selfref_iterator</a>.  <a href="structeagine_1_1selfref__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1basic__transforming__iterator.html">eagine::basic_transforming_iterator&lt; Iterator, T, S, Transform, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator transforming the referenced elements.  <a href="classeagine_1_1basic__transforming__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1transforming__iterator.html">eagine::transforming_iterator&lt; Iterator, T, S, Transform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of <a class="el" href="classeagine_1_1basic__transforming__iterator.html" title="Iterator transforming the referenced elements.">basic_transforming_iterator</a>.  <a href="structeagine_1_1transforming__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1basic__noexcept__casting__iterator.html">eagine::basic_noexcept_casting_iterator&lt; Iterator, T, S, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type-casting the referenced elements.  <a href="classeagine_1_1basic__noexcept__casting__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1noexcept__casting__iterator.html">eagine::noexcept_casting_iterator&lt; Iterator, T, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of <a class="el" href="classeagine_1_1basic__noexcept__casting__iterator.html" title="Iterator type-casting the referenced elements.">basic_noexcept_casting_iterator</a>.  <a href="structeagine_1_1noexcept__casting__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1reverse.html">eagine::reverse&lt; Range &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter reversing the iteration of elements in a Range.  <a href="classeagine_1_1reverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1some__true.html">eagine::some_true</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing initially false value and logically or-ing other values.  <a href="classeagine_1_1some__true.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1static__enum__map.html">eagine::static_enum_map&lt; Enum, Unit, Keys &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class mapping from an enumerator of an instantiation of a template.  <a href="classeagine_1_1static__enum__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1memory_1_1typed__nullptr__t.html">eagine::memory::typed_nullptr_t&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for doing pointer arithmetic on null pointers.  <a href="structeagine_1_1memory_1_1typed__nullptr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadda8aac5370bd7ae56cb5a16defd16f4"><td class="memTemplParams" colspan="2"><a id="gadda8aac5370bd7ae56cb5a16defd16f4"></a>
template&lt;bool B&gt; </td></tr>
<tr class="memitem:gadda8aac5370bd7ae56cb5a16defd16f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gadda8aac5370bd7ae56cb5a16defd16f4">eagine::bool_constant</a> = std::integral_constant&lt; bool, B &gt;</td></tr>
<tr class="memdesc:gadda8aac5370bd7ae56cb5a16defd16f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for boolean constant type. <br /></td></tr>
<tr class="separator:gadda8aac5370bd7ae56cb5a16defd16f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga870c8270c3b77a0da93f276783d2f8f1"><td class="memTemplParams" colspan="2"><a id="ga870c8270c3b77a0da93f276783d2f8f1"></a>
template&lt;int I&gt; </td></tr>
<tr class="memitem:ga870c8270c3b77a0da93f276783d2f8f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga870c8270c3b77a0da93f276783d2f8f1">eagine::int_constant</a> = std::integral_constant&lt; int, I &gt;</td></tr>
<tr class="memdesc:ga870c8270c3b77a0da93f276783d2f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for signed int constant type. <br /></td></tr>
<tr class="separator:ga870c8270c3b77a0da93f276783d2f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a0b020f0b6a0616a07c71440000c06"><td class="memTemplParams" colspan="2"><a id="ga60a0b020f0b6a0616a07c71440000c06"></a>
template&lt;unsigned U&gt; </td></tr>
<tr class="memitem:ga60a0b020f0b6a0616a07c71440000c06"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga60a0b020f0b6a0616a07c71440000c06">eagine::unsigned_constant</a> = std::integral_constant&lt; unsigned, U &gt;</td></tr>
<tr class="memdesc:ga60a0b020f0b6a0616a07c71440000c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for unsigned int constant type. <br /></td></tr>
<tr class="separator:ga60a0b020f0b6a0616a07c71440000c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf4e8677167f3bbf423c824b1847e66f"><td class="memTemplParams" colspan="2"><a id="gacf4e8677167f3bbf423c824b1847e66f"></a>
template&lt;std::size_t S&gt; </td></tr>
<tr class="memitem:gacf4e8677167f3bbf423c824b1847e66f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gacf4e8677167f3bbf423c824b1847e66f">eagine::size_constant</a> = std::integral_constant&lt; std::size_t, S &gt;</td></tr>
<tr class="memdesc:gacf4e8677167f3bbf423c824b1847e66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for size_t constant type. <br /></td></tr>
<tr class="separator:gacf4e8677167f3bbf423c824b1847e66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe944538990f9399b4ba44485e823fe"><td class="memTemplParams" colspan="2">template&lt;identifier_t Id&gt; </td></tr>
<tr class="memitem:gafbe944538990f9399b4ba44485e823fe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gafbe944538990f9399b4ba44485e823fe">eagine::id_constant</a> = std::integral_constant&lt; <a class="el" href="group__identifiers.html#ga95fc7f47f20633e9563dcaa76d1bce4b">identifier_t</a>, Id &gt;</td></tr>
<tr class="memdesc:gafbe944538990f9399b4ba44485e823fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for identifier_t constant type.  <a href="group__type__utils.html#gafbe944538990f9399b4ba44485e823fe">More...</a><br /></td></tr>
<tr class="separator:gafbe944538990f9399b4ba44485e823fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973e3bb89ea2c57a0e9204e9ffc0167e"><td class="memItemLeft" align="right" valign="top"><a id="ga973e3bb89ea2c57a0e9204e9ffc0167e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">eagine::byte</a> = unsigned char</td></tr>
<tr class="memdesc:ga973e3bb89ea2c57a0e9204e9ffc0167e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte type alias. <br /></td></tr>
<tr class="separator:ga973e3bb89ea2c57a0e9204e9ffc0167e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d0d8a7358b42ac745edd78ca686f7b"><td class="memItemLeft" align="right" valign="top"><a id="ga99d0d8a7358b42ac745edd78ca686f7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga99d0d8a7358b42ac745edd78ca686f7b">eagine::std_align_t</a> = std::size_t</td></tr>
<tr class="memdesc:ga99d0d8a7358b42ac745edd78ca686f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment type used by std. <br /></td></tr>
<tr class="separator:ga99d0d8a7358b42ac745edd78ca686f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c466d5e3bc1c923488ba79fd191363"><td class="memItemLeft" align="right" valign="top"><a id="gaa2c466d5e3bc1c923488ba79fd191363"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaa2c466d5e3bc1c923488ba79fd191363">eagine::std_size_t</a> = std::size_t</td></tr>
<tr class="memdesc:gaa2c466d5e3bc1c923488ba79fd191363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type used by std. <br /></td></tr>
<tr class="separator:gaa2c466d5e3bc1c923488ba79fd191363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c24c96dddc1fd15429ed38f016d1ef"><td class="memItemLeft" align="right" valign="top"><a id="ga45c24c96dddc1fd15429ed38f016d1ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">eagine::span_size_t</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ga45c24c96dddc1fd15429ed38f016d1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed span size type used by eagine. <br /></td></tr>
<tr class="separator:ga45c24c96dddc1fd15429ed38f016d1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbaa82e72e4244fec591e7e012cf949a"><td class="memItemLeft" align="right" valign="top"><a id="gafbaa82e72e4244fec591e7e012cf949a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gafbaa82e72e4244fec591e7e012cf949a">eagine::valid_span_size</a> = <a class="el" href="group__valid__if.html#ga00a51ba271fbb9ff4d3e1432e2bb0513">valid_if_nonnegative</a>&lt; <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &gt;</td></tr>
<tr class="memdesc:gafbaa82e72e4244fec591e7e012cf949a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid size type. <br /></td></tr>
<tr class="separator:gafbaa82e72e4244fec591e7e012cf949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da7f49dadf801add5106aeaaf050f7b"><td class="memTemplParams" colspan="2"><a id="ga8da7f49dadf801add5106aeaaf050f7b"></a>
template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:ga8da7f49dadf801add5106aeaaf050f7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">eagine::memory::basic_block</a> = <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; std::conditional_t&lt; IsConst, const <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a>, <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga8da7f49dadf801add5106aeaaf050f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for byte spans. <br /></td></tr>
<tr class="separator:ga8da7f49dadf801add5106aeaaf050f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c7c5d04307871d98a76686b17ebba4"><td class="memTemplParams" colspan="2">template&lt;typename std::size_t B&gt; </td></tr>
<tr class="memitem:gad5c7c5d04307871d98a76686b17ebba4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gad5c7c5d04307871d98a76686b17ebba4">eagine::biteset_cell_type</a> = std::conditional_t&lt;(B&lt;=8), std::uint_least8_t, std::conditional_t&lt;(B&lt;=16), std::uint_least16_t, std::conditional_t&lt;(B&lt;=32), std::uint_least32_t, std::conditional_t&lt;(B&lt;=64), std::uint_least64_t, void &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:gad5c7c5d04307871d98a76686b17ebba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the appropriate type for biteset element representation.  <a href="group__type__utils.html#gad5c7c5d04307871d98a76686b17ebba4">More...</a><br /></td></tr>
<tr class="separator:gad5c7c5d04307871d98a76686b17ebba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd294528813ac25d56decb0e5194089"><td class="memTemplParams" colspan="2"><a id="gadbd294528813ac25d56decb0e5194089"></a>
template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:gadbd294528813ac25d56decb0e5194089"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gadbd294528813ac25d56decb0e5194089">eagine::memory::basic_split_block</a> = <a class="el" href="classeagine_1_1memory_1_1basic__split__span.html">basic_split_span</a>&lt; std::conditional_t&lt; IsConst, const <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a>, <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a> &gt; &gt;</td></tr>
<tr class="memdesc:gadbd294528813ac25d56decb0e5194089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for split span of bytes. <br /></td></tr>
<tr class="separator:gadbd294528813ac25d56decb0e5194089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b6b865401692708c34a55a96d4c12a2"><td class="memItemLeft" align="right" valign="top"><a id="ga5b6b865401692708c34a55a96d4c12a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga5b6b865401692708c34a55a96d4c12a2">eagine::work_done</a> = <a class="el" href="classeagine_1_1some__true.html">some_true</a></td></tr>
<tr class="memdesc:ga5b6b865401692708c34a55a96d4c12a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias used as return value indicating that some work was done. <br /></td></tr>
<tr class="separator:ga5b6b865401692708c34a55a96d4c12a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga758b4c07ecbad155292049a1ac84c1a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:ga758b4c07ecbad155292049a1ac84c1a9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga758b4c07ecbad155292049a1ac84c1a9">eagine::memory::all_of</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) -&gt; bool</td></tr>
<tr class="memdesc:ga758b4c07ecbad155292049a1ac84c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if all elements in a span satisfy <code>predicate</code>.  <a href="group__type__utils.html#ga758b4c07ecbad155292049a1ac84c1a9">More...</a><br /></td></tr>
<tr class="separator:ga758b4c07ecbad155292049a1ac84c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e95e4cf9b917f2d3c7be40121a69d6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:ga25e95e4cf9b917f2d3c7be40121a69d6"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga25e95e4cf9b917f2d3c7be40121a69d6">eagine::memory::any_of</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) -&gt; bool</td></tr>
<tr class="memdesc:ga25e95e4cf9b917f2d3c7be40121a69d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if any elements in a span satisfy <code>predicate</code>.  <a href="group__type__utils.html#ga25e95e4cf9b917f2d3c7be40121a69d6">More...</a><br /></td></tr>
<tr class="separator:ga25e95e4cf9b917f2d3c7be40121a69d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c35f296f41b5d9c7ca97339f15c540e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:ga2c35f296f41b5d9c7ca97339f15c540e"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga2c35f296f41b5d9c7ca97339f15c540e">eagine::memory::none_of</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) -&gt; bool</td></tr>
<tr class="memdesc:ga2c35f296f41b5d9c7ca97339f15c540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if no elements in a span satisfy <code>predicate</code>.  <a href="group__type__utils.html#ga2c35f296f41b5d9c7ca97339f15c540e">More...</a><br /></td></tr>
<tr class="separator:ga2c35f296f41b5d9c7ca97339f15c540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a82d71f37fbdf764e2800d4316ea352"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:ga3a82d71f37fbdf764e2800d4316ea352"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga3a82d71f37fbdf764e2800d4316ea352">eagine::memory::for_each_delimited</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; delim, UnaryOperation unary_op)</td></tr>
<tr class="memdesc:ga3a82d71f37fbdf764e2800d4316ea352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans span for parts split by delimiter, calls a function for each part.  <a href="group__type__utils.html#ga3a82d71f37fbdf764e2800d4316ea352">More...</a><br /></td></tr>
<tr class="separator:ga3a82d71f37fbdf764e2800d4316ea352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae35e9ec5c2a721f696b50d75990ea8a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:gaae35e9ec5c2a721f696b50d75990ea8a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaae35e9ec5c2a721f696b50d75990ea8a">eagine::memory::for_each_chunk</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> len, UnaryOperation unary_op)</td></tr>
<tr class="memdesc:gaae35e9ec5c2a721f696b50d75990ea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits span into parts of equal length, calls a function for each part.  <a href="group__type__utils.html#gaae35e9ec5c2a721f696b50d75990ea8a">More...</a><br /></td></tr>
<tr class="separator:gaae35e9ec5c2a721f696b50d75990ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f63e33945c8333851fc873a094f8b87"><td class="memTemplParams" colspan="2"><a id="ga0f63e33945c8333851fc873a094f8b87"></a>
template&lt;typename Result , typename T , typename P1 , typename S1 , typename P2 , typename S2 , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga0f63e33945c8333851fc873a094f8b87"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga0f63e33945c8333851fc873a094f8b87">eagine::memory::basic_edit_distance</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; const T, P1, S1 &gt; s1, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; const T, P2, S2 &gt; s2, BinaryFunction get_distance) -&gt; Result</td></tr>
<tr class="memdesc:ga0f63e33945c8333851fc873a094f8b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the edit distance of <code>s1</code> and <code>s2</code> according to get_distance. <br /></td></tr>
<tr class="separator:ga0f63e33945c8333851fc873a094f8b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b899da7126aa5f44d4b69991e74a01"><td class="memTemplParams" colspan="2"><a id="ga26b899da7126aa5f44d4b69991e74a01"></a>
template&lt;typename T , typename B , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga26b899da7126aa5f44d4b69991e74a01"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga26b899da7126aa5f44d4b69991e74a01">eagine::memory::can_accommodate</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; B, P, S &gt; blk, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> count, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt; tid={}) noexcept</td></tr>
<tr class="memdesc:ga26b899da7126aa5f44d4b69991e74a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the specified memory block can accommodate count elements of T. <br /></td></tr>
<tr class="separator:ga26b899da7126aa5f44d4b69991e74a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9178bfa80d482c7afb2cba917b4eba09"><td class="memTemplParams" colspan="2"><a id="ga9178bfa80d482c7afb2cba917b4eba09"></a>
template&lt;typename T , typename B , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga9178bfa80d482c7afb2cba917b4eba09"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga9178bfa80d482c7afb2cba917b4eba09">eagine::memory::can_accommodate</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; B, P, S &gt; blk, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt; tid={}) noexcept</td></tr>
<tr class="memdesc:ga9178bfa80d482c7afb2cba917b4eba09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the specified memory block can accommodate one element of T. <br /></td></tr>
<tr class="separator:ga9178bfa80d482c7afb2cba917b4eba09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec2c03ccfb83e3c84d829e631ec61bc"><td class="memTemplParams" colspan="2"><a id="gafec2c03ccfb83e3c84d829e631ec61bc"></a>
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:gafec2c03ccfb83e3c84d829e631ec61bc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gafec2c03ccfb83e3c84d829e631ec61bc">eagine::std_align</a> (const T v) noexcept</td></tr>
<tr class="memdesc:gafec2c03ccfb83e3c84d829e631ec61bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to std alignment type. <br /></td></tr>
<tr class="separator:gafec2c03ccfb83e3c84d829e631ec61bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga283b8d65986d9151df656e7802ea0caf"><td class="memTemplParams" colspan="2"><a id="ga283b8d65986d9151df656e7802ea0caf"></a>
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga283b8d65986d9151df656e7802ea0caf"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga283b8d65986d9151df656e7802ea0caf">eagine::std_size</a> (const T v) noexcept</td></tr>
<tr class="memdesc:ga283b8d65986d9151df656e7802ea0caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to std size type. <br /></td></tr>
<tr class="separator:ga283b8d65986d9151df656e7802ea0caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d3047b5216d5051cfb6781ea922d21"><td class="memTemplParams" colspan="2"><a id="ga37d3047b5216d5051cfb6781ea922d21"></a>
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga37d3047b5216d5051cfb6781ea922d21"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga37d3047b5216d5051cfb6781ea922d21">eagine::span_size</a> (const T v) noexcept</td></tr>
<tr class="memdesc:ga37d3047b5216d5051cfb6781ea922d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to span size type. <br /></td></tr>
<tr class="separator:ga37d3047b5216d5051cfb6781ea922d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cfd5092e7be96db6a5c1a28f61203ab"><td class="memTemplParams" colspan="2"><a id="ga7cfd5092e7be96db6a5c1a28f61203ab"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7cfd5092e7be96db6a5c1a28f61203ab"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga7cfd5092e7be96db6a5c1a28f61203ab">eagine::span_align_of</a> (const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}) noexcept</td></tr>
<tr class="memdesc:ga7cfd5092e7be96db6a5c1a28f61203ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte alignment of type T as span_size_t. <br /></td></tr>
<tr class="separator:ga7cfd5092e7be96db6a5c1a28f61203ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da29a349a0c54ae40001ec06b9ab247"><td class="memTemplParams" colspan="2"><a id="ga5da29a349a0c54ae40001ec06b9ab247"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5da29a349a0c54ae40001ec06b9ab247"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga5da29a349a0c54ae40001ec06b9ab247">eagine::span_size_of</a> (const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}) noexcept</td></tr>
<tr class="memdesc:ga5da29a349a0c54ae40001ec06b9ab247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte size of type T as span_size_t. <br /></td></tr>
<tr class="separator:ga5da29a349a0c54ae40001ec06b9ab247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f36044dad42140a44afa77ceb841b66"><td class="memTemplParams" colspan="2"><a id="ga6f36044dad42140a44afa77ceb841b66"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga6f36044dad42140a44afa77ceb841b66"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga6f36044dad42140a44afa77ceb841b66">eagine::span_size_of</a> (const S n, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}) noexcept</td></tr>
<tr class="memdesc:ga6f36044dad42140a44afa77ceb841b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total byte size of n elements of type T as span_size_t. <br /></td></tr>
<tr class="separator:ga6f36044dad42140a44afa77ceb841b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69b9dea4fef2484ee81ac7887a794a0"><td class="memTemplParams" colspan="2">template&lt;typename Dst , typename Src &gt; </td></tr>
<tr class="memitem:gad69b9dea4fef2484ee81ac7887a794a0"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gad69b9dea4fef2484ee81ac7887a794a0">eagine::is_within_limits</a> (const Src value) noexcept</td></tr>
<tr class="memdesc:gad69b9dea4fef2484ee81ac7887a794a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if <code>value</code> fits into the specified Dst type.  <a href="group__type__utils.html#gad69b9dea4fef2484ee81ac7887a794a0">More...</a><br /></td></tr>
<tr class="separator:gad69b9dea4fef2484ee81ac7887a794a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f37fdb64aba28d20aaffce61a856fcc"><td class="memTemplParams" colspan="2">template&lt;typename Dst , typename Src &gt; </td></tr>
<tr class="memitem:ga9f37fdb64aba28d20aaffce61a856fcc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga9f37fdb64aba28d20aaffce61a856fcc">eagine::limit_cast</a> (Src value) noexcept -&gt; Dst requires(std::is_convertible_v&lt; Src, Dst &gt;)</td></tr>
<tr class="memdesc:ga9f37fdb64aba28d20aaffce61a856fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>value</code> to Dst type if the value fits in that type.  <a href="group__type__utils.html#ga9f37fdb64aba28d20aaffce61a856fcc">More...</a><br /></td></tr>
<tr class="separator:ga9f37fdb64aba28d20aaffce61a856fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8b694f300be481e0193d6d79cae6ec"><td class="memTemplParams" colspan="2">template&lt;typename Src &gt; </td></tr>
<tr class="memitem:gaaf8b694f300be481e0193d6d79cae6ec"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaaf8b694f300be481e0193d6d79cae6ec">eagine::signedness_cast</a> (Src value) noexcept</td></tr>
<tr class="memdesc:gaaf8b694f300be481e0193d6d79cae6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>value</code> to a type with the opposite signedness.  <a href="group__type__utils.html#gaaf8b694f300be481e0193d6d79cae6ec">More...</a><br /></td></tr>
<tr class="separator:gaaf8b694f300be481e0193d6d79cae6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad916e4f63189d2cf1c8e49ceafd34a4c"><td class="memTemplParams" colspan="2">template&lt;typename Dst , typename Src &gt; </td></tr>
<tr class="memitem:gad916e4f63189d2cf1c8e49ceafd34a4c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gad916e4f63189d2cf1c8e49ceafd34a4c">eagine::convert_if_fits</a> (Src value) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; Dst &gt; requires(std::is_convertible_v&lt; Src, Dst &gt;)</td></tr>
<tr class="memdesc:gad916e4f63189d2cf1c8e49ceafd34a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally converts <code>value</code> to Dst type if the value fits in that type.  <a href="group__type__utils.html#gad916e4f63189d2cf1c8e49ceafd34a4c">More...</a><br /></td></tr>
<tr class="separator:gad916e4f63189d2cf1c8e49ceafd34a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a996f91405f500ffe768c7bb5d73d7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2a996f91405f500ffe768c7bb5d73d7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga2a996f91405f500ffe768c7bb5d73d7d">eagine::from_string</a> (const <a class="el" href="group__string__utils.html#gae76dd3f0edeca37e438f5bbc2374e1b9">string_view</a> src) noexcept</td></tr>
<tr class="memdesc:ga2a996f91405f500ffe768c7bb5d73d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string representation in <code>src</code> to a value of type <code>T</code>.  <a href="group__type__utils.html#ga2a996f91405f500ffe768c7bb5d73d7d">More...</a><br /></td></tr>
<tr class="separator:ga2a996f91405f500ffe768c7bb5d73d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958b912e64539f65c7fe18fda68bf9c2"><td class="memTemplParams" colspan="2">template&lt;typename T , identifier_t V&gt; </td></tr>
<tr class="memitem:ga958b912e64539f65c7fe18fda68bf9c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga958b912e64539f65c7fe18fda68bf9c2">eagine::from_string</a> (const <a class="el" href="group__string__utils.html#gae76dd3f0edeca37e438f5bbc2374e1b9">string_view</a> src, const <a class="el" href="structeagine_1_1selector.html">selector</a>&lt; V &gt; sel) noexcept</td></tr>
<tr class="memdesc:ga958b912e64539f65c7fe18fda68bf9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string representation in <code>src</code> to a value of type <code>T</code>.  <a href="group__type__utils.html#ga958b912e64539f65c7fe18fda68bf9c2">More...</a><br /></td></tr>
<tr class="separator:ga958b912e64539f65c7fe18fda68bf9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5bfddc9b8e49e175b1a40f9e6f72f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4d5bfddc9b8e49e175b1a40f9e6f72f6"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga4d5bfddc9b8e49e175b1a40f9e6f72f6">eagine::type_name</a> (const T &amp;) noexcept -&gt; std::string</td></tr>
<tr class="memdesc:ga4d5bfddc9b8e49e175b1a40f9e6f72f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the demangled name for type T.  <a href="group__type__utils.html#ga4d5bfddc9b8e49e175b1a40f9e6f72f6">More...</a><br /></td></tr>
<tr class="separator:ga4d5bfddc9b8e49e175b1a40f9e6f72f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4465c961f40f266eef9e3c9453beccac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4465c961f40f266eef9e3c9453beccac"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga4465c961f40f266eef9e3c9453beccac">eagine::type_name</a> () noexcept -&gt; std::string</td></tr>
<tr class="memdesc:ga4465c961f40f266eef9e3c9453beccac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the demangled name for type T.  <a href="group__type__utils.html#ga4465c961f40f266eef9e3c9453beccac">More...</a><br /></td></tr>
<tr class="separator:ga4465c961f40f266eef9e3c9453beccac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b43ace0fa8a67d88532f25650607800"><td class="memTemplParams" colspan="2"><a id="ga0b43ace0fa8a67d88532f25650607800"></a>
template&lt;typename H , typename I &gt; </td></tr>
<tr class="memitem:ga0b43ace0fa8a67d88532f25650607800"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga0b43ace0fa8a67d88532f25650607800">eagine::integer_hash</a> (const I x, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; H &gt; hid={}, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; I &gt; iid={}) -&gt; H</td></tr>
<tr class="memdesc:ga0b43ace0fa8a67d88532f25650607800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hash value with type <code>H</code> from an integer value of type <code>I</code>. <br /></td></tr>
<tr class="separator:ga0b43ace0fa8a67d88532f25650607800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a72fe43272bd6f8f7e0cdbb41b3bce5"><td class="memTemplParams" colspan="2"><a id="ga8a72fe43272bd6f8f7e0cdbb41b3bce5"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga8a72fe43272bd6f8f7e0cdbb41b3bce5"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga8a72fe43272bd6f8f7e0cdbb41b3bce5">eagine::array_size</a> (const T(&amp;)[N]) noexcept</td></tr>
<tr class="memdesc:ga8a72fe43272bd6f8f7e0cdbb41b3bce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the array passed as argument. <br /></td></tr>
<tr class="separator:ga8a72fe43272bd6f8f7e0cdbb41b3bce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e0dc28debce7b8adb1669dcc8c83afd"><td class="memTemplParams" colspan="2"><a id="ga4e0dc28debce7b8adb1669dcc8c83afd"></a>
template&lt;typename T , std::integral N&gt; </td></tr>
<tr class="memitem:ga4e0dc28debce7b8adb1669dcc8c83afd"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga4e0dc28debce7b8adb1669dcc8c83afd">eagine::memory::operator+</a> (const <a class="el" href="structeagine_1_1memory_1_1typed__nullptr__t.html">typed_nullptr_t</a>&lt; T &gt;, const N n) noexcept -&gt; T *</td></tr>
<tr class="memdesc:ga4e0dc28debce7b8adb1669dcc8c83afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer arithmetic addition operator for null pointers. <br /></td></tr>
<tr class="separator:ga4e0dc28debce7b8adb1669dcc8c83afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c98535512962555b502e009479f3ba7"><td class="memTemplParams" colspan="2"><a id="ga0c98535512962555b502e009479f3ba7"></a>
template&lt;typename Selector , typename T &gt; </td></tr>
<tr class="memitem:ga0c98535512962555b502e009479f3ba7"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga0c98535512962555b502e009479f3ba7">get_member</a> (<a class="el" href="classeagine_1_1protected__member.html">protected_member</a>&lt; T, Selector &gt; &amp;pm, Selector <a class="el" href="structeagine_1_1selector.html">selector</a>=Selector()) noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:ga0c98535512962555b502e009479f3ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the member stored in <a class="el" href="classeagine_1_1protected__member.html" title="Class holding a single tagged data member.">protected_member</a>. <br /></td></tr>
<tr class="separator:ga0c98535512962555b502e009479f3ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da0d63183fa6309a51fae8694037651"><td class="memTemplParams" colspan="2"><a id="ga9da0d63183fa6309a51fae8694037651"></a>
template&lt;typename Selector , typename T &gt; </td></tr>
<tr class="memitem:ga9da0d63183fa6309a51fae8694037651"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga9da0d63183fa6309a51fae8694037651">get_member</a> (const <a class="el" href="classeagine_1_1protected__member.html">protected_member</a>&lt; T, Selector &gt; &amp;pm, Selector <a class="el" href="structeagine_1_1selector.html">selector</a>=Selector()) noexcept -&gt; const T &amp;</td></tr>
<tr class="memdesc:ga9da0d63183fa6309a51fae8694037651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the member stored in <a class="el" href="classeagine_1_1protected__member.html" title="Class holding a single tagged data member.">protected_member</a>. <br /></td></tr>
<tr class="separator:ga9da0d63183fa6309a51fae8694037651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4fceddaea892fd61b87e44d6f55f6c"><td class="memTemplParams" colspan="2">template&lt;typename Traits &gt; </td></tr>
<tr class="memitem:gacc4fceddaea892fd61b87e44d6f55f6c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gacc4fceddaea892fd61b87e44d6f55f6c">operator+</a> (const <a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;l, const <a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;r) noexcept -&gt; <a class="el" href="classeagine_1_1c__api_1_1key__value__list.html">key_value_list</a>&lt; Traits &gt;</td></tr>
<tr class="memdesc:gacc4fceddaea892fd61b87e44d6f55f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two individual key/value elements into a key/value list.  <a href="group__type__utils.html#gacc4fceddaea892fd61b87e44d6f55f6c">More...</a><br /></td></tr>
<tr class="separator:gacc4fceddaea892fd61b87e44d6f55f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fa1c9bb976bdb842bbf538020377e33"><td class="memTemplParams" colspan="2">template&lt;typename Traits &gt; </td></tr>
<tr class="memitem:ga8fa1c9bb976bdb842bbf538020377e33"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga8fa1c9bb976bdb842bbf538020377e33">operator+</a> (const <a class="el" href="classeagine_1_1c__api_1_1key__value__list.html">key_value_list</a>&lt; Traits &gt; &amp;l, const <a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;r) noexcept -&gt; <a class="el" href="classeagine_1_1c__api_1_1key__value__list.html">key_value_list</a>&lt; Traits &gt;</td></tr>
<tr class="memdesc:ga8fa1c9bb976bdb842bbf538020377e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key/value pair into a key/value list, returns a new list.  <a href="group__type__utils.html#ga8fa1c9bb976bdb842bbf538020377e33">More...</a><br /></td></tr>
<tr class="separator:ga8fa1c9bb976bdb842bbf538020377e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga4845b1f7afe8748b7761f3229740862e"><td class="memTemplParams" colspan="2"><a id="ga4845b1f7afe8748b7761f3229740862e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4845b1f7afe8748b7761f3229740862e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga4845b1f7afe8748b7761f3229740862e">eagine::memory::has_span_size_member_v</a></td></tr>
<tr class="memdesc:ga4845b1f7afe8748b7761f3229740862e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait indicating if type T has x.size() member function. <br /></td></tr>
<tr class="separator:ga4845b1f7afe8748b7761f3229740862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f881de38cee58d6b2527ce33e441f30"><td class="memTemplParams" colspan="2"><a id="ga9f881de38cee58d6b2527ce33e441f30"></a>
template&lt;typename T , typename E  = anything&gt; </td></tr>
<tr class="memitem:ga9f881de38cee58d6b2527ce33e441f30"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga9f881de38cee58d6b2527ce33e441f30">eagine::memory::has_span_data_member_v</a></td></tr>
<tr class="memdesc:ga9f881de38cee58d6b2527ce33e441f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait indicating if type T has x.size() member function. <br /></td></tr>
<tr class="separator:ga9f881de38cee58d6b2527ce33e441f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d81cd9c527e46b245b6e7d5ef0af12"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structeagine_1_1nothing__t.html">nothing_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaa8d81cd9c527e46b245b6e7d5ef0af12">eagine::nothing</a></td></tr>
<tr class="memdesc:gaa8d81cd9c527e46b245b6e7d5ef0af12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of <a class="el" href="structeagine_1_1nothing__t.html" title="Class representing &quot;none&quot; / &quot;nothing&quot; values.">nothing_t</a> type.  <a href="group__type__utils.html#gaa8d81cd9c527e46b245b6e7d5ef0af12">More...</a><br /></td></tr>
<tr class="separator:gaa8d81cd9c527e46b245b6e7d5ef0af12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941076769a0bc079cb82bff2d9be7397"><td class="memTemplParams" colspan="2"><a id="ga941076769a0bc079cb82bff2d9be7397"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga941076769a0bc079cb82bff2d9be7397"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structeagine_1_1memory_1_1typed__nullptr__t.html">typed_nullptr_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga941076769a0bc079cb82bff2d9be7397">eagine::memory::typed_nullptr</a></td></tr>
<tr class="memdesc:ga941076769a0bc079cb82bff2d9be7397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template constant for doing pointer arithmetic on null pointers. <br /></td></tr>
<tr class="separator:ga941076769a0bc079cb82bff2d9be7397"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad5c7c5d04307871d98a76686b17ebba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c7c5d04307871d98a76686b17ebba4">&#9670;&nbsp;</a></span>biteset_cell_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename std::size_t B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__type__utils.html#gad5c7c5d04307871d98a76686b17ebba4">eagine::biteset_cell_type</a> = typedef std::conditional_t&lt; (B &lt;= 8), std::uint_least8_t, std::conditional_t&lt; (B &lt;= 16), std::uint_least16_t, std::conditional_t&lt; (B &lt;= 32), std::uint_least32_t, std::conditional_t&lt;(B &lt;= 64), std::uint_least64_t, void&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the appropriate type for biteset element representation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1biteset.html" title="Sequence of unsigned integer values with specified number bits.">biteset</a> </dd></dl>

</div>
</div>
<a id="gafbe944538990f9399b4ba44485e823fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbe944538990f9399b4ba44485e823fe">&#9670;&nbsp;</a></span>id_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;identifier_t Id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__type__utils.html#gafbe944538990f9399b4ba44485e823fe">eagine::id_constant</a> = typedef std::integral_constant&lt;<a class="el" href="group__identifiers.html#ga95fc7f47f20633e9563dcaa76d1bce4b">identifier_t</a>, Id&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for identifier_t constant type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__identifiers.html#ga95fc7f47f20633e9563dcaa76d1bce4b" title="The underlying integer type for eagine::identifier.">identifier_t</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga758b4c07ecbad155292049a1ac84c1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga758b4c07ecbad155292049a1ac84c1a9">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::all_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if all elements in a span satisfy <code>predicate</code>. </p>
<dl class="section see"><dt>See also</dt><dd>any_of </dd>
<dd>
none_of </dd></dl>

</div>
</div>
<a id="ga25e95e4cf9b917f2d3c7be40121a69d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e95e4cf9b917f2d3c7be40121a69d6">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::any_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if any elements in a span satisfy <code>predicate</code>. </p>
<dl class="section see"><dt>See also</dt><dd>all_of </dd>
<dd>
none_of </dd></dl>

</div>
</div>
<a id="gad916e4f63189d2cf1c8e49ceafd34a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad916e4f63189d2cf1c8e49ceafd34a4c">&#9670;&nbsp;</a></span>convert_if_fits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dst , typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::convert_if_fits </td>
          <td>(</td>
          <td class="paramtype">Src&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;Dst&gt; requires(std::is_convertible_v&lt;Src, Dst&gt;) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optionally converts <code>value</code> to Dst type if the value fits in that type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#gad69b9dea4fef2484ee81ac7887a794a0" title="Indicates if value fits into the specified Dst type.">is_within_limits</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#ga9f37fdb64aba28d20aaffce61a856fcc" title="Casts value to Dst type if the value fits in that type.">limit_cast</a> </dd></dl>

</div>
</div>
<a id="gaae35e9ec5c2a721f696b50d75990ea8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae35e9ec5c2a721f696b50d75990ea8a">&#9670;&nbsp;</a></span>for_each_chunk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename UnaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void eagine::memory::for_each_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits span into parts of equal length, calls a function for each part. </p>
<dl class="section see"><dt>See also</dt><dd>for_each_delimited </dd></dl>

</div>
</div>
<a id="ga3a82d71f37fbdf764e2800d4316ea352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a82d71f37fbdf764e2800d4316ea352">&#9670;&nbsp;</a></span>for_each_delimited()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 , typename UnaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void eagine::memory::for_each_delimited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans span for parts split by delimiter, calls a function for each part. </p>
<dl class="section see"><dt>See also</dt><dd>for_each_chunk </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1url.html#a533ab109ccdb7224e0d9527f21d8391f">eagine::url::argument()</a>, and <a class="el" href="classeagine_1_1url.html#acbc06e0c71359d2c3c980d0b18a767af">eagine::url::query()</a>.</p>

</div>
</div>
<a id="ga2a996f91405f500ffe768c7bb5d73d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a996f91405f500ffe768c7bb5d73d7d">&#9670;&nbsp;</a></span>from_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto eagine::from_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__string__utils.html#gae76dd3f0edeca37e438f5bbc2374e1b9">string_view</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the string representation in <code>src</code> to a value of type <code>T</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#gad69b9dea4fef2484ee81ac7887a794a0" title="Indicates if value fits into the specified Dst type.">is_within_limits</a> </dd></dl>

</div>
</div>
<a id="ga958b912e64539f65c7fe18fda68bf9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga958b912e64539f65c7fe18fda68bf9c2">&#9670;&nbsp;</a></span>from_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , identifier_t V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto eagine::from_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__string__utils.html#gae76dd3f0edeca37e438f5bbc2374e1b9">string_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1selector.html">selector</a>&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the string representation in <code>src</code> to a value of type <code>T</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#gad69b9dea4fef2484ee81ac7887a794a0" title="Indicates if value fits into the specified Dst type.">is_within_limits</a></dd></dl>
<p>This overload allows to specify a selector that can change the value conversion rules. </p>

</div>
</div>
<a id="gad69b9dea4fef2484ee81ac7887a794a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69b9dea4fef2484ee81ac7887a794a0">&#9670;&nbsp;</a></span>is_within_limits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dst , typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::is_within_limits </td>
          <td>(</td>
          <td class="paramtype">const Src&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if <code>value</code> fits into the specified Dst type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#ga9f37fdb64aba28d20aaffce61a856fcc" title="Casts value to Dst type if the value fits in that type.">limit_cast</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#gad916e4f63189d2cf1c8e49ceafd34a4c" title="Optionally converts value to Dst type if the value fits in that type.">convert_if_fits</a></dd></dl>
<p>This function tests if the specified argument would fit into another type. For example if a value stored in 64-bit integer can be converted into a 16-bit integer without overflow. </p>

</div>
</div>
<a id="ga9f37fdb64aba28d20aaffce61a856fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f37fdb64aba28d20aaffce61a856fcc">&#9670;&nbsp;</a></span>limit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dst , typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::limit_cast </td>
          <td>(</td>
          <td class="paramtype">Src&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; Dst
  requires(std::is_convertible_v&lt;Src, Dst&gt;) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts <code>value</code> to Dst type if the value fits in that type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#gad69b9dea4fef2484ee81ac7887a794a0" title="Indicates if value fits into the specified Dst type.">is_within_limits</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#gad916e4f63189d2cf1c8e49ceafd34a4c" title="Optionally converts value to Dst type if the value fits in that type.">convert_if_fits</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#gaaf8b694f300be481e0193d6d79cae6ec" title="Casts value to a type with the opposite signedness.">signedness_cast</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>is_within_limits&lt;Dst&gt;(value) </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1msgbus_1_1remote__node.html#a09b077eda6edc11b7ca4b00bbe57c005">eagine::msgbus::remote_node::messages_per_second()</a>.</p>

</div>
</div>
<a id="ga2c35f296f41b5d9c7ca97339f15c540e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c35f296f41b5d9c7ca97339f15c540e">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::none_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if no elements in a span satisfy <code>predicate</code>. </p>
<dl class="section see"><dt>See also</dt><dd>all_of </dd>
<dd>
any_of </dd></dl>

</div>
</div>
<a id="ga8fa1c9bb976bdb842bbf538020377e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fa1c9bb976bdb842bbf538020377e33">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1c__api_1_1key__value__list.html">key_value_list</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1c__api_1_1key__value__list.html">key_value_list</a>&lt;Traits&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a key/value pair into a key/value list, returns a new list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html" title="A single key/value pair for a key/value list.">key_value_list_element</a> </dd></dl>

</div>
</div>
<a id="gacc4fceddaea892fd61b87e44d6f55f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc4fceddaea892fd61b87e44d6f55f6c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1c__api_1_1key__value__list.html">key_value_list</a>&lt;Traits&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two individual key/value elements into a key/value list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structeagine_1_1c__api_1_1key__value__list__element.html" title="A single key/value pair for a key/value list.">key_value_list_element</a> </dd></dl>

</div>
</div>
<a id="gaaf8b694f300be481e0193d6d79cae6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8b694f300be481e0193d6d79cae6ec">&#9670;&nbsp;</a></span>signedness_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::signedness_cast </td>
          <td>(</td>
          <td class="paramtype">Src&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts <code>value</code> to a type with the opposite signedness. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#gad69b9dea4fef2484ee81ac7887a794a0" title="Indicates if value fits into the specified Dst type.">is_within_limits</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#gad916e4f63189d2cf1c8e49ceafd34a4c" title="Optionally converts value to Dst type if the value fits in that type.">convert_if_fits</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#ga9f37fdb64aba28d20aaffce61a856fcc" title="Casts value to Dst type if the value fits in that type.">limit_cast</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="app_2028_compute_particles_2resources_8cpp-example.html#a4">app/028_compute_particles/resources.cpp</a>, and <a class="el" href="oglplus_2022_octree_8cpp-example.html#a9">oglplus/022_octree.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga4465c961f40f266eef9e3c9453beccac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4465c961f40f266eef9e3c9453beccac">&#9670;&nbsp;</a></span>type_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::string </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the demangled name for type T. </p>
<dl class="section note"><dt>Note</dt><dd>The result is implementation dependent. </dd></dl>

</div>
</div>
<a id="ga4d5bfddc9b8e49e175b1a40f9e6f72f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5bfddc9b8e49e175b1a40f9e6f72f6">&#9670;&nbsp;</a></span>type_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::type_name </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::string </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the demangled name for type T. </p>
<dl class="section note"><dt>Note</dt><dd>The result is implementation dependent. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaa8d81cd9c527e46b245b6e7d5ef0af12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d81cd9c527e46b245b6e7d5ef0af12">&#9670;&nbsp;</a></span>nothing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structeagine_1_1nothing__t.html">nothing_t</a> eagine::nothing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant of <a class="el" href="structeagine_1_1nothing__t.html" title="Class representing &quot;none&quot; / &quot;nothing&quot; values.">nothing_t</a> type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structeagine_1_1nothing__t.html" title="Class representing &quot;none&quot; / &quot;nothing&quot; values.">nothing_t</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="eagine_2msgbus_2005_topology_8cpp-example.html#a4">eagine/msgbus/005_topology.cpp</a>, and <a class="el" href="eagine_2msgbus_2007_ping_8cpp-example.html#a2">eagine/msgbus/007_ping.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1msgbus_1_1connection__setup.html#ab17fa2b793f72980e6d1f9c9727331c6">eagine::msgbus::connection_setup::connection_setup()</a>, <a class="el" href="classeagine_1_1msgbus_1_1router__address.html#ae7ddec182bc2ebd9bfd09aedcf7b96db">eagine::msgbus::router_address::router_address()</a>, <a class="el" href="classeagine_1_1shared__executable__module.html#afbcfb172584febba5fbe7c4c661b64ea">eagine::shared_executable_module::shared_executable_module()</a>, <a class="el" href="classeagine_1_1msgbus_1_1remote__instance.html#a56c084a074957c1514a7764aa894c715">eagine::msgbus::remote_instance::build()</a>, <a class="el" href="classeagine_1_1msgbus_1_1remote__instance.html#a53f17bee42e3e3fde1e626c0fbaeb2cc">eagine::msgbus::remote_instance::compiler()</a>, <a class="el" href="classeagine_1_1shared__executable__module.html#a0b04607f1d12e3ad65c4b44f1518b690">eagine::shared_executable_module::open_self()</a>, and <a class="el" href="classeagine_1_1msgbus_1_1remote__node.html#a82f982603cade8da0383e8e671a3abd5">eagine::msgbus::remote_node::set_ping_interval()</a>.</p>

</div>
</div>
</div><!-- contents -->
<br/>
<div id="eagine-bottom">
<em>Copyright &copy; 2015-2022</em> <strong>Mat Chochlk</strong>.<br/>
&lt;<a href="mailto:chochlik@gmail.com">chochlik -at -gmail.com</a>&gt;<br/>
Documentation generated on Wed May 18 2022 by <a href="http://www.doxygen.org/index.html">Doxygen</a> (version 1.9.1).
</div> <!-- eagine-bottom -->
</div> <!-- eagine-content -->
</div> <!-- eagine-frame -->
</body>
</html>
