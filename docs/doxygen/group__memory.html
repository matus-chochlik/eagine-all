<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="author" content="Matus Chochlik"/>
<meta name="copyright" content="Copyright 2015-2021 Matus Chochlik"/>
<meta name="keywords" content="C++ EGL OpenGL OpenAL Graphics Rendering"/>
<meta name="description" content="C++ wrapper for rendering C APIs"/>
<title>Memory utilities</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="eagine.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="eagine-frame">
<div id="eagine-bar">
	<div id="eagine-top">
	<div id="eagine-top-content">
		<div id="eagine-caption">
	   		<div id="eagine-brief">
					<span id="eagine-name">EAGine&#160;</span>
					<span id="eagine-version">(0.87.0)</span> a C++ wrapper for rendering APIs
				</div>
		</div>
		<hr/>
	</div>
	</div>
	<div id="eagine-icon">
		<a href="http://oglplus.org/"><img src="../eagine.png"/></a>
	</div>
</div>
<div id="eagine-content">
<div id="top">
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__address.html">eagine::memory::basic_address&lt; IsConst &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling memory addresses as integer values.  <a href="classeagine_1_1memory_1_1basic__address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1aligned__block.html">eagine::memory::aligned_block&lt; Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class containing store of the specified size convertible to block.  <a href="classeagine_1_1memory_1_1aligned__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1owned__block.html">eagine::memory::owned_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of block indicating byte span ownership.  <a href="classeagine_1_1memory_1_1owned__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1block__owner.html">eagine::memory::block_owner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for classes that act as memory block owners.  <a href="classeagine_1_1memory_1_1block__owner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1buffer.html">eagine::memory::buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocatable owning byte buffer.  <a href="classeagine_1_1memory_1_1buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1buffer__pool.html">eagine::memory::buffer_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple reusable memory buffer instances.  <a href="classeagine_1_1memory_1_1buffer__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">eagine::memory::basic_offset_ptr&lt; Pointee, OffsetType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic offset pointer class template.  <a href="classeagine_1_1memory_1_1basic__offset__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__split__span.html">eagine::memory::basic_split_span&lt; ValueType, Pointer, SizeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for classes representing a memory span split in two parts.  <a href="classeagine_1_1memory_1_1basic__split__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac012f79ffaff88e2f2ebeb2ab9cf4709"><td class="memItemLeft" align="right" valign="top"><a id="gac012f79ffaff88e2f2ebeb2ab9cf4709"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">eagine::memory::const_address</a> = <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; true &gt;</td></tr>
<tr class="memdesc:gac012f79ffaff88e2f2ebeb2ab9cf4709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for const memory address values. <br /></td></tr>
<tr class="separator:gac012f79ffaff88e2f2ebeb2ab9cf4709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62558a22bf49982834d2fc9d56aa4a48"><td class="memItemLeft" align="right" valign="top"><a id="ga62558a22bf49982834d2fc9d56aa4a48"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga62558a22bf49982834d2fc9d56aa4a48">eagine::memory::address</a> = <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; false &gt;</td></tr>
<tr class="memdesc:ga62558a22bf49982834d2fc9d56aa4a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for non-const memory address values. <br /></td></tr>
<tr class="separator:ga62558a22bf49982834d2fc9d56aa4a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd5ce1a14209336eb031bc930d736f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">eagine::memory::block</a> = <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt; false &gt;</td></tr>
<tr class="memdesc:ga5dd5ce1a14209336eb031bc930d736f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for non-const byte memory span.  <a href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">More...</a><br /></td></tr>
<tr class="separator:ga5dd5ce1a14209336eb031bc930d736f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abe6f67096b87cac1c3116a66379971"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">eagine::memory::const_block</a> = <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt; true &gt;</td></tr>
<tr class="memdesc:ga9abe6f67096b87cac1c3116a66379971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for const byte memory span.  <a href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">More...</a><br /></td></tr>
<tr class="separator:ga9abe6f67096b87cac1c3116a66379971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06677f578748e6082e4f2c80ac628e51"><td class="memTemplParams" colspan="2"><a id="ga06677f578748e6082e4f2c80ac628e51"></a>
template&lt;typename Pointee &gt; </td></tr>
<tr class="memitem:ga06677f578748e6082e4f2c80ac628e51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga06677f578748e6082e4f2c80ac628e51">eagine::memory::offset_ptr</a> = <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; Pointee, std::ptrdiff_t &gt;</td></tr>
<tr class="memdesc:ga06677f578748e6082e4f2c80ac628e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default type alias for basic offset pointer. <br /></td></tr>
<tr class="separator:ga06677f578748e6082e4f2c80ac628e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6e361736e3af8e290d01ff4cce3f8c"><td class="memTemplParams" colspan="2"><a id="ga1d6e361736e3af8e290d01ff4cce3f8c"></a>
template&lt;typename Pointee &gt; </td></tr>
<tr class="memitem:ga1d6e361736e3af8e290d01ff4cce3f8c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1d6e361736e3af8e290d01ff4cce3f8c">eagine::memory::short_offset_ptr</a> = <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; Pointee, short &gt;</td></tr>
<tr class="memdesc:ga1d6e361736e3af8e290d01ff4cce3f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for basic offset pointer with short offset. <br /></td></tr>
<tr class="separator:ga1d6e361736e3af8e290d01ff4cce3f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f410f4f987f538a32f3dfaa16357ce"><td class="memTemplParams" colspan="2"><a id="gac9f410f4f987f538a32f3dfaa16357ce"></a>
template&lt;typename T , typename O  = span_size_t, typename S  = span_size_t&gt; </td></tr>
<tr class="memitem:gac9f410f4f987f538a32f3dfaa16357ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac9f410f4f987f538a32f3dfaa16357ce">eagine::memory::basic_offset_span</a> = <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; T, O &gt;, S &gt;</td></tr>
<tr class="memdesc:gac9f410f4f987f538a32f3dfaa16357ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic alias for <a class="el" href="classeagine_1_1memory_1_1basic__span.html" title="Non-owning view of a contiguous range of memory with ValueType elements.">basic_span</a> with basic_offset_pointer. <br /></td></tr>
<tr class="separator:gac9f410f4f987f538a32f3dfaa16357ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a8de3b337fbad8d2b789962564ff6e"><td class="memTemplParams" colspan="2"><a id="ga10a8de3b337fbad8d2b789962564ff6e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga10a8de3b337fbad8d2b789962564ff6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga10a8de3b337fbad8d2b789962564ff6e">eagine::memory::offset_span</a> = <a class="el" href="group__memory.html#gac9f410f4f987f538a32f3dfaa16357ce">basic_offset_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga10a8de3b337fbad8d2b789962564ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for basic_offset_span. <br /></td></tr>
<tr class="separator:ga10a8de3b337fbad8d2b789962564ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51eebf35c26db72a8735cf80a569099"><td class="memTemplParams" colspan="2"><a id="gad51eebf35c26db72a8735cf80a569099"></a>
template&lt;typename T , typename S  = span_size_t&gt; </td></tr>
<tr class="memitem:gad51eebf35c26db72a8735cf80a569099"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad51eebf35c26db72a8735cf80a569099">eagine::memory::span</a> = <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, T *, S &gt;</td></tr>
<tr class="memdesc:gad51eebf35c26db72a8735cf80a569099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for basic memory spans with native pointer type. <br /></td></tr>
<tr class="separator:gad51eebf35c26db72a8735cf80a569099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894d4cf6e581395b9212297f1f66b538"><td class="memTemplParams" colspan="2"><a id="ga894d4cf6e581395b9212297f1f66b538"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga894d4cf6e581395b9212297f1f66b538"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">eagine::memory::span_if_mutable</a> = std::enable_if_t&lt;!std::is_const_v&lt; T &gt;, <a class="el" href="group__memory.html#gad51eebf35c26db72a8735cf80a569099">span</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga894d4cf6e581395b9212297f1f66b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for span&lt;T&gt; if T is mutable type. Ill defined otherwise. <br /></td></tr>
<tr class="separator:ga894d4cf6e581395b9212297f1f66b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"><td class="memTemplParams" colspan="2"><a id="ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">eagine::memory::const_span</a> = <a class="el" href="group__memory.html#gad51eebf35c26db72a8735cf80a569099">span</a>&lt; std::add_const_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for spans with const element type. <br /></td></tr>
<tr class="separator:ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e857a2c58956474d39318c8128bc797"><td class="memTemplParams" colspan="2"><a id="ga4e857a2c58956474d39318c8128bc797"></a>
template&lt;typename T , span_size_t chunkSize&gt; </td></tr>
<tr class="memitem:ga4e857a2c58956474d39318c8128bc797"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4e857a2c58956474d39318c8128bc797">eagine::memory::chunk_span</a> = <a class="el" href="classeagine_1_1memory_1_1basic__chunk__span.html">basic_chunk_span</a>&lt; T, T *, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>, chunkSize &gt;</td></tr>
<tr class="memdesc:ga4e857a2c58956474d39318c8128bc797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for basic memory chunk spans with native pointer type. <br /></td></tr>
<tr class="separator:ga4e857a2c58956474d39318c8128bc797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d90edae2138d5bfebc1e06008530821"><td class="memItemLeft" align="right" valign="top"><a id="ga7d90edae2138d5bfebc1e06008530821"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga7d90edae2138d5bfebc1e06008530821">eagine::memory::split_block</a> = <a class="el" href="group__type__utils.html#gadbd294528813ac25d56decb0e5194089">basic_split_block</a>&lt; false &gt;</td></tr>
<tr class="memdesc:ga7d90edae2138d5bfebc1e06008530821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for non-const split blocks. <br /></td></tr>
<tr class="separator:ga7d90edae2138d5bfebc1e06008530821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf559dcbcc620d163248b4034f0d3c7c8"><td class="memItemLeft" align="right" valign="top"><a id="gaf559dcbcc620d163248b4034f0d3c7c8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf559dcbcc620d163248b4034f0d3c7c8">eagine::memory::const_split_block</a> = <a class="el" href="group__type__utils.html#gadbd294528813ac25d56decb0e5194089">basic_split_block</a>&lt; true &gt;</td></tr>
<tr class="memdesc:gaf559dcbcc620d163248b4034f0d3c7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for const split blocks. <br /></td></tr>
<tr class="separator:gaf559dcbcc620d163248b4034f0d3c7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3a17060222729d5624485ee2c7d08a5a"><td class="memTemplParams" colspan="2"><a id="ga3a17060222729d5624485ee2c7d08a5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a17060222729d5624485ee2c7d08a5a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga3a17060222729d5624485ee2c7d08a5a">eagine::memory::as_address</a> (T *addr) noexcept</td></tr>
<tr class="memdesc:ga3a17060222729d5624485ee2c7d08a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a pointer to <a class="el" href="classeagine_1_1memory_1_1basic__address.html" title="Class for handling memory addresses as integer values.">basic_address</a>. <br /></td></tr>
<tr class="separator:ga3a17060222729d5624485ee2c7d08a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b30863eae231d94187a4fcb4babad8"><td class="memItemLeft" align="right" valign="top"><a id="gad7b30863eae231d94187a4fcb4babad8"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gad7b30863eae231d94187a4fcb4babad8">eagine::memory::misalignment</a> (<a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">const_address</a> addr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept</td></tr>
<tr class="memdesc:gad7b30863eae231d94187a4fcb4babad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the misalignment of a memory address to the specified alignment. <br /></td></tr>
<tr class="separator:gad7b30863eae231d94187a4fcb4babad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4881068c75e5a276226a91bb55bcc2f1"><td class="memItemLeft" align="right" valign="top"><a id="ga4881068c75e5a276226a91bb55bcc2f1"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4881068c75e5a276226a91bb55bcc2f1">eagine::memory::misalignment</a> (const void *ptr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept</td></tr>
<tr class="memdesc:ga4881068c75e5a276226a91bb55bcc2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the misalignment of a pointer to the specified alignment. <br /></td></tr>
<tr class="separator:ga4881068c75e5a276226a91bb55bcc2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9467ba9509c5ff41342b9264e68c267f"><td class="memItemLeft" align="right" valign="top"><a id="ga9467ba9509c5ff41342b9264e68c267f"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga9467ba9509c5ff41342b9264e68c267f">eagine::memory::is_aligned_to</a> (<a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">const_address</a> addr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept</td></tr>
<tr class="memdesc:ga9467ba9509c5ff41342b9264e68c267f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a memory address aligned to the specified alignment. <br /></td></tr>
<tr class="separator:ga9467ba9509c5ff41342b9264e68c267f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab683bc9f50e2ee6a49108c5f8983c4e"><td class="memItemLeft" align="right" valign="top"><a id="gaab683bc9f50e2ee6a49108c5f8983c4e"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaab683bc9f50e2ee6a49108c5f8983c4e">eagine::memory::is_aligned_to</a> (const void *ptr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept</td></tr>
<tr class="memdesc:gaab683bc9f50e2ee6a49108c5f8983c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a pointer is aligned to the specified alignment. <br /></td></tr>
<tr class="separator:gaab683bc9f50e2ee6a49108c5f8983c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef41efc70d1781f9c75c3cba74d88404"><td class="memTemplParams" colspan="2"><a id="gaef41efc70d1781f9c75c3cba74d88404"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef41efc70d1781f9c75c3cba74d88404"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaef41efc70d1781f9c75c3cba74d88404">eagine::memory::is_aligned_as</a> (<a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">const_address</a> addr, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt; tid={}) noexcept</td></tr>
<tr class="memdesc:gaef41efc70d1781f9c75c3cba74d88404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a memory address aligned as the specified type T. <br /></td></tr>
<tr class="separator:gaef41efc70d1781f9c75c3cba74d88404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bf6d48a299d6cb9ccc091bf4e3fa84a"><td class="memTemplParams" colspan="2">template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:ga3bf6d48a299d6cb9ccc091bf4e3fa84a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga3bf6d48a299d6cb9ccc091bf4e3fa84a">eagine::memory::align_up</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt; addr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> max) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt;</td></tr>
<tr class="memdesc:ga3bf6d48a299d6cb9ccc091bf4e3fa84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address up to the specified alignment.  <a href="group__memory.html#ga3bf6d48a299d6cb9ccc091bf4e3fa84a">More...</a><br /></td></tr>
<tr class="separator:ga3bf6d48a299d6cb9ccc091bf4e3fa84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a58b3dadbde62e6c31b11bc73eeacc"><td class="memTemplParams" colspan="2">template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:gac6a58b3dadbde62e6c31b11bc73eeacc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac6a58b3dadbde62e6c31b11bc73eeacc">eagine::memory::align_down</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt; addr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> max) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt;</td></tr>
<tr class="memdesc:gac6a58b3dadbde62e6c31b11bc73eeacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address down to the specified alignment.  <a href="group__memory.html#gac6a58b3dadbde62e6c31b11bc73eeacc">More...</a><br /></td></tr>
<tr class="separator:gac6a58b3dadbde62e6c31b11bc73eeacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad114b31a9251943942c411b8d6303c67"><td class="memTemplParams" colspan="2"><a id="gad114b31a9251943942c411b8d6303c67"></a>
template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:gad114b31a9251943942c411b8d6303c67"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad114b31a9251943942c411b8d6303c67">eagine::memory::align_down</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt; addr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align) noexcept</td></tr>
<tr class="memdesc:gad114b31a9251943942c411b8d6303c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address down to the specified alignment. <br /></td></tr>
<tr class="separator:gad114b31a9251943942c411b8d6303c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5c1799d3fd3674ee8c2847439819cc"><td class="memItemLeft" align="right" valign="top"><a id="ga1b5c1799d3fd3674ee8c2847439819cc"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1b5c1799d3fd3674ee8c2847439819cc">eagine::memory::align_down</a> (const <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a> *ptr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align) -&gt; const <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a> *</td></tr>
<tr class="memdesc:ga1b5c1799d3fd3674ee8c2847439819cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a byte pointer down to the specified alignment. <br /></td></tr>
<tr class="separator:ga1b5c1799d3fd3674ee8c2847439819cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88809b30e4be19991c30dbf9fbb3f33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac88809b30e4be19991c30dbf9fbb3f33"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac88809b30e4be19991c30dbf9fbb3f33">eagine::memory::align_up_to</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; T &gt;&gt; addr, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align=<a class="el" href="group__type__utils.html#ga7cfd5092e7be96db6a5c1a28f61203ab">span_align_of</a>&lt; T &gt;(), const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> max=<a class="el" href="group__type__utils.html#ga5da29a349a0c54ae40001ec06b9ab247">span_size_of</a>&lt; T &gt;()) noexcept</td></tr>
<tr class="memdesc:gac88809b30e4be19991c30dbf9fbb3f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address up to the required alignment of type T.  <a href="group__memory.html#gac88809b30e4be19991c30dbf9fbb3f33">More...</a><br /></td></tr>
<tr class="separator:gac88809b30e4be19991c30dbf9fbb3f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af2919ea33b999d3226a85d77c8bc8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8af2919ea33b999d3226a85d77c8bc8a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga8af2919ea33b999d3226a85d77c8bc8a">eagine::memory::align_down_to</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; T &gt;&gt; addr, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align=<a class="el" href="group__type__utils.html#ga7cfd5092e7be96db6a5c1a28f61203ab">span_align_of</a>&lt; T &gt;(), const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> max=<a class="el" href="group__type__utils.html#ga5da29a349a0c54ae40001ec06b9ab247">span_size_of</a>&lt; T &gt;()) noexcept</td></tr>
<tr class="memdesc:ga8af2919ea33b999d3226a85d77c8bc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address down to the required alignment of type T.  <a href="group__memory.html#ga8af2919ea33b999d3226a85d77c8bc8a">More...</a><br /></td></tr>
<tr class="separator:ga8af2919ea33b999d3226a85d77c8bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d342bc0efbef06a9315a0127f041de"><td class="memItemLeft" align="right" valign="top"><a id="gac3d342bc0efbef06a9315a0127f041de"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gac3d342bc0efbef06a9315a0127f041de">eagine::memory::misalignment</a> (const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> addr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept -&gt; <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a></td></tr>
<tr class="memdesc:gac3d342bc0efbef06a9315a0127f041de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates basic numeric address misalignment. <br /></td></tr>
<tr class="separator:gac3d342bc0efbef06a9315a0127f041de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d81feb10ff18ed4c958e43a6551b8ae"><td class="memItemLeft" align="right" valign="top"><a id="ga5d81feb10ff18ed4c958e43a6551b8ae"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5d81feb10ff18ed4c958e43a6551b8ae">eagine::memory::misalignment</a> (const std::nullptr_t, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>) noexcept -&gt; <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a></td></tr>
<tr class="memdesc:ga5d81feb10ff18ed4c958e43a6551b8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates basic numeric address misalignment. <br /></td></tr>
<tr class="separator:ga5d81feb10ff18ed4c958e43a6551b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a5b47ca71ad2313b275fa6ef482ce4"><td class="memItemLeft" align="right" valign="top"><a id="gaa6a5b47ca71ad2313b275fa6ef482ce4"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa6a5b47ca71ad2313b275fa6ef482ce4">eagine::memory::is_aligned_to</a> (const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> addr, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> algn) noexcept</td></tr>
<tr class="memdesc:gaa6a5b47ca71ad2313b275fa6ef482ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a basic numeric address is aligned. <br /></td></tr>
<tr class="separator:gaa6a5b47ca71ad2313b275fa6ef482ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad128896cf98935aef16bc7c9bd41f1c9"><td class="memItemLeft" align="right" valign="top"><a id="gad128896cf98935aef16bc7c9bd41f1c9"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gad128896cf98935aef16bc7c9bd41f1c9">eagine::memory::is_aligned_to</a> (const std::nullptr_t, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>) noexcept</td></tr>
<tr class="memdesc:gad128896cf98935aef16bc7c9bd41f1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a basic numeric address is aligned. <br /></td></tr>
<tr class="separator:gad128896cf98935aef16bc7c9bd41f1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1352f1ea8cb98276a3671fe326a8c41e"><td class="memTemplParams" colspan="2"><a id="ga1352f1ea8cb98276a3671fe326a8c41e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1352f1ea8cb98276a3671fe326a8c41e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1352f1ea8cb98276a3671fe326a8c41e">eagine::memory::is_aligned_as</a> (const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> addr, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}) noexcept</td></tr>
<tr class="memdesc:ga1352f1ea8cb98276a3671fe326a8c41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a basic numeric address is aligned to alignment of type T. <br /></td></tr>
<tr class="separator:ga1352f1ea8cb98276a3671fe326a8c41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d5b348a30a24217bcf763dfab47e19b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga2d5b348a30a24217bcf763dfab47e19b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga2d5b348a30a24217bcf763dfab47e19b">eagine::memory::as_bytes</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) noexcept -&gt; <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt; std::is_const_v&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:ga2d5b348a30a24217bcf763dfab47e19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a span into a basic_block.  <a href="group__memory.html#ga2d5b348a30a24217bcf763dfab47e19b">More...</a><br /></td></tr>
<tr class="separator:ga2d5b348a30a24217bcf763dfab47e19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ac2f99ccac9b9fab354f56bff6ddf6"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga74ac2f99ccac9b9fab354f56bff6ddf6">eagine::memory::as_chars</a> (const <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a> blk) noexcept</td></tr>
<tr class="memdesc:ga74ac2f99ccac9b9fab354f56bff6ddf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a block into a span of characters.  <a href="group__memory.html#ga74ac2f99ccac9b9fab354f56bff6ddf6">More...</a><br /></td></tr>
<tr class="separator:ga74ac2f99ccac9b9fab354f56bff6ddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a137e2cf62bd132b54ca445a5d93c5"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga49a137e2cf62bd132b54ca445a5d93c5">eagine::memory::as_chars</a> (const <a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a> blk) noexcept</td></tr>
<tr class="memdesc:ga49a137e2cf62bd132b54ca445a5d93c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a block into a span of characters.  <a href="group__memory.html#ga49a137e2cf62bd132b54ca445a5d93c5">More...</a><br /></td></tr>
<tr class="separator:ga49a137e2cf62bd132b54ca445a5d93c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617108b1fef48ea67b32f98c346b9b8e"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga617108b1fef48ea67b32f98c346b9b8e">eagine::memory::copy</a> (const <a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a> source, <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a> dest) noexcept -&gt; <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a></td></tr>
<tr class="memdesc:ga617108b1fef48ea67b32f98c346b9b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of source block to destination block.  <a href="group__memory.html#ga617108b1fef48ea67b32f98c346b9b8e">More...</a><br /></td></tr>
<tr class="separator:ga617108b1fef48ea67b32f98c346b9b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb27620c9e29d7365a08a5686f0c3bba"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gadb27620c9e29d7365a08a5686f0c3bba">eagine::memory::copy_into</a> (const <a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a> source, <a class="el" href="classeagine_1_1memory_1_1buffer.html">buffer</a> &amp;dest) noexcept -&gt; <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a></td></tr>
<tr class="memdesc:gadb27620c9e29d7365a08a5686f0c3bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of source block to destination buffer.  <a href="group__memory.html#gadb27620c9e29d7365a08a5686f0c3bba">More...</a><br /></td></tr>
<tr class="separator:gadb27620c9e29d7365a08a5686f0c3bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32e12e4506d0ac5ffa26397d3140ffa"><td class="memTemplParams" colspan="2"><a id="gaf32e12e4506d0ac5ffa26397d3140ffa"></a>
template&lt;typename P , typename O &gt; </td></tr>
<tr class="memitem:gaf32e12e4506d0ac5ffa26397d3140ffa"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf32e12e4506d0ac5ffa26397d3140ffa">eagine::memory::as_address</a> (<a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; P, O &gt; op) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; P &gt;&gt;</td></tr>
<tr class="memdesc:gaf32e12e4506d0ac5ffa26397d3140ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html" title="Basic offset pointer class template.">basic_offset_ptr</a> into <a class="el" href="classeagine_1_1memory_1_1basic__address.html" title="Class for handling memory addresses as integer values.">basic_address</a>. <br /></td></tr>
<tr class="separator:gaf32e12e4506d0ac5ffa26397d3140ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2bd8629c6e69e1b9ee40ad72e61876"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:gadd2bd8629c6e69e1b9ee40ad72e61876"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gadd2bd8629c6e69e1b9ee40ad72e61876">eagine::memory::relative</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; T, std::make_signed_t&lt; S &gt;&gt;, S &gt;</td></tr>
<tr class="memdesc:gadd2bd8629c6e69e1b9ee40ad72e61876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to span using an offset pointer type.  <a href="group__memory.html#gadd2bd8629c6e69e1b9ee40ad72e61876">More...</a><br /></td></tr>
<tr class="separator:gadd2bd8629c6e69e1b9ee40ad72e61876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27c0cdcfa69797e43615d234ce753f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:gad27c0cdcfa69797e43615d234ce753f6"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad27c0cdcfa69797e43615d234ce753f6">eagine::memory::absolute</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, T *, S &gt;</td></tr>
<tr class="memdesc:gad27c0cdcfa69797e43615d234ce753f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to span using a native pointer type.  <a href="group__memory.html#gad27c0cdcfa69797e43615d234ce753f6">More...</a><br /></td></tr>
<tr class="separator:gad27c0cdcfa69797e43615d234ce753f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c38aab41b4986aa356cee68a658c79"><td class="memTemplParams" colspan="2"><a id="gaa1c38aab41b4986aa356cee68a658c79"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1c38aab41b4986aa356cee68a658c79"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa1c38aab41b4986aa356cee68a658c79">eagine::memory::view_one</a> (const T &amp;value) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gaa1c38aab41b4986aa356cee68a658c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single-const-element view over the specified value. <br /></td></tr>
<tr class="separator:gaa1c38aab41b4986aa356cee68a658c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c24b3a8932dad93aa92ec7c7da67436"><td class="memTemplParams" colspan="2"><a id="ga4c24b3a8932dad93aa92ec7c7da67436"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4c24b3a8932dad93aa92ec7c7da67436"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4c24b3a8932dad93aa92ec7c7da67436">eagine::memory::cover_one</a> (T &amp;value) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga4c24b3a8932dad93aa92ec7c7da67436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single-element mutable span over the specified value. <br /></td></tr>
<tr class="separator:ga4c24b3a8932dad93aa92ec7c7da67436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6258fd8a67a0544bec4355c9909a299a"><td class="memTemplParams" colspan="2"><a id="ga6258fd8a67a0544bec4355c9909a299a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6258fd8a67a0544bec4355c9909a299a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6258fd8a67a0544bec4355c9909a299a">eagine::memory::view_one</a> (const T *pointer) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga6258fd8a67a0544bec4355c9909a299a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single-const-element view from the specified pointer. <br /></td></tr>
<tr class="separator:ga6258fd8a67a0544bec4355c9909a299a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52128e793163289fdbb62ac544cd1fcd"><td class="memTemplParams" colspan="2"><a id="ga52128e793163289fdbb62ac544cd1fcd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga52128e793163289fdbb62ac544cd1fcd"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga52128e793163289fdbb62ac544cd1fcd">eagine::memory::cover_one</a> (T *pointer) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga52128e793163289fdbb62ac544cd1fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single-element mutable span from the specified pointer. <br /></td></tr>
<tr class="separator:ga52128e793163289fdbb62ac544cd1fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9534fdd13884329a5c5e5c10b3337f80"><td class="memTemplParams" colspan="2"><a id="ga9534fdd13884329a5c5e5c10b3337f80"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga9534fdd13884329a5c5e5c10b3337f80"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga9534fdd13884329a5c5e5c10b3337f80">eagine::memory::view</a> (T *addr, const S size) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga9534fdd13884329a5c5e5c10b3337f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view starting at the specified pointer and specified length. <br /></td></tr>
<tr class="separator:ga9534fdd13884329a5c5e5c10b3337f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323cd8c49fef908990c9d5b5553576b4"><td class="memTemplParams" colspan="2"><a id="ga323cd8c49fef908990c9d5b5553576b4"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga323cd8c49fef908990c9d5b5553576b4"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga323cd8c49fef908990c9d5b5553576b4">eagine::memory::cover</a> (T *addr, const S size) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga323cd8c49fef908990c9d5b5553576b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span starting at the specified pointer and specified length. <br /></td></tr>
<tr class="separator:ga323cd8c49fef908990c9d5b5553576b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ec719398d5faa7d327ae27c08d14d7"><td class="memTemplParams" colspan="2"><a id="gaf3ec719398d5faa7d327ae27c08d14d7"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gaf3ec719398d5faa7d327ae27c08d14d7"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf3ec719398d5faa7d327ae27c08d14d7">eagine::memory::view</a> (<a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">const_address</a> addr, const S size) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gaf3ec719398d5faa7d327ae27c08d14d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view starting at the specified address and specified length. <br /></td></tr>
<tr class="separator:gaf3ec719398d5faa7d327ae27c08d14d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77b6a6dc614fad401bc0d0cef9c6235"><td class="memTemplParams" colspan="2"><a id="gac77b6a6dc614fad401bc0d0cef9c6235"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gac77b6a6dc614fad401bc0d0cef9c6235"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac77b6a6dc614fad401bc0d0cef9c6235">eagine::memory::cover</a> (<a class="el" href="group__memory.html#ga62558a22bf49982834d2fc9d56aa4a48">address</a> addr, const S size) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gac77b6a6dc614fad401bc0d0cef9c6235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span starting at the specified address and specified length. <br /></td></tr>
<tr class="separator:gac77b6a6dc614fad401bc0d0cef9c6235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a65df5e51410fde4984224f8dfbd25a"><td class="memTemplParams" colspan="2"><a id="ga4a65df5e51410fde4984224f8dfbd25a"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga4a65df5e51410fde4984224f8dfbd25a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4a65df5e51410fde4984224f8dfbd25a">eagine::memory::view</a> (const T(&amp;array)[N]) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga4a65df5e51410fde4984224f8dfbd25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const view over the specified fixed-size array. <br /></td></tr>
<tr class="separator:ga4a65df5e51410fde4984224f8dfbd25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9fa13ff28cf204b49336f60740f86da"><td class="memTemplParams" colspan="2"><a id="gae9fa13ff28cf204b49336f60740f86da"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gae9fa13ff28cf204b49336f60740f86da"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gae9fa13ff28cf204b49336f60740f86da">eagine::memory::cover</a> (T(&amp;array)[N]) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gae9fa13ff28cf204b49336f60740f86da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mutable span covering the specified fixed-size array. <br /></td></tr>
<tr class="separator:gae9fa13ff28cf204b49336f60740f86da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f9278cf40fbc76cbfbb04be0c29667"><td class="memTemplParams" colspan="2"><a id="ga19f9278cf40fbc76cbfbb04be0c29667"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19f9278cf40fbc76cbfbb04be0c29667"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga19f9278cf40fbc76cbfbb04be0c29667">eagine::memory::view</a> (std::initializer_list&lt; T &gt; il) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga19f9278cf40fbc76cbfbb04be0c29667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const view over the specified initializer list. <br /></td></tr>
<tr class="separator:ga19f9278cf40fbc76cbfbb04be0c29667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8fd3ed063cbc9db585861aac2262f9"><td class="memTemplParams" colspan="2"><a id="ga1e8fd3ed063cbc9db585861aac2262f9"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:ga1e8fd3ed063cbc9db585861aac2262f9"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1e8fd3ed063cbc9db585861aac2262f9">eagine::memory::view</a> (const C &amp;container) noexcept requires(has_span_data_member_v&lt; C &gt; &amp;&amp;has_span_size_member_v&lt; C &gt;)</td></tr>
<tr class="memdesc:ga1e8fd3ed063cbc9db585861aac2262f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const view over a compatible contiguous container. <br /></td></tr>
<tr class="separator:ga1e8fd3ed063cbc9db585861aac2262f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4725f6799ac1b5c490e56260bbd789df"><td class="memTemplParams" colspan="2"><a id="ga4725f6799ac1b5c490e56260bbd789df"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:ga4725f6799ac1b5c490e56260bbd789df"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4725f6799ac1b5c490e56260bbd789df">eagine::memory::cover</a> (C &amp;container) noexcept requires(has_span_data_member_v&lt; C &gt; &amp;&amp;has_span_size_member_v&lt; C &gt;)</td></tr>
<tr class="memdesc:ga4725f6799ac1b5c490e56260bbd789df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mutable span covering a compatible contiguous container. <br /></td></tr>
<tr class="separator:ga4725f6799ac1b5c490e56260bbd789df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cc5174f2f1a431a7c85f3f3f8b7081"><td class="memTemplParams" colspan="2">template&lt;typename T , typename B , typename P , typename S &gt; </td></tr>
<tr class="memitem:gad1cc5174f2f1a431a7c85f3f3f8b7081"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad1cc5174f2f1a431a7c85f3f3f8b7081">eagine::memory::accommodate</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; B, P, S &gt; blk, const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt; tid={}) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, rebind_pointer_t&lt; P, T &gt;, S &gt;</td></tr>
<tr class="memdesc:gad1cc5174f2f1a431a7c85f3f3f8b7081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a span, rebinding the element type (typically from basic_block).  <a href="group__memory.html#gad1cc5174f2f1a431a7c85f3f3f8b7081">More...</a><br /></td></tr>
<tr class="separator:gad1cc5174f2f1a431a7c85f3f3f8b7081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05e741e072a75182869ff2c0cfbb83be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga05e741e072a75182869ff2c0cfbb83be"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga05e741e072a75182869ff2c0cfbb83be">eagine::memory::extract</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:ga05e741e072a75182869ff2c0cfbb83be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of extract for spans. Returns the first element,.  <a href="group__memory.html#ga05e741e072a75182869ff2c0cfbb83be">More...</a><br /></td></tr>
<tr class="separator:ga05e741e072a75182869ff2c0cfbb83be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924678aab0e9e49147b5cd038ab68754"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename I , typename L &gt; </td></tr>
<tr class="memitem:ga924678aab0e9e49147b5cd038ab68754"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga924678aab0e9e49147b5cd038ab68754">eagine::memory::slice</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, const I i, const L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga924678aab0e9e49147b5cd038ab68754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span starting at specified index with specified length.  <a href="group__memory.html#ga924678aab0e9e49147b5cd038ab68754">More...</a><br /></td></tr>
<tr class="separator:ga924678aab0e9e49147b5cd038ab68754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb44c79939a13fac26cb489d52ef660"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:ga8eb44c79939a13fac26cb489d52ef660"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga8eb44c79939a13fac26cb489d52ef660">eagine::memory::skip</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, const L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga8eb44c79939a13fac26cb489d52ef660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips a specified count of elements from the front of a span.  <a href="group__memory.html#ga8eb44c79939a13fac26cb489d52ef660">More...</a><br /></td></tr>
<tr class="separator:ga8eb44c79939a13fac26cb489d52ef660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94ba8cc892b237b54a760d3c84a14e5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:gaf94ba8cc892b237b54a760d3c84a14e5"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf94ba8cc892b237b54a760d3c84a14e5">eagine::memory::snip</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, const L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gaf94ba8cc892b237b54a760d3c84a14e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snips a specified count of elements from the back of a span.  <a href="group__memory.html#gaf94ba8cc892b237b54a760d3c84a14e5">More...</a><br /></td></tr>
<tr class="separator:gaf94ba8cc892b237b54a760d3c84a14e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad784eb701a135080a9593bb3fd1116c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:gad784eb701a135080a9593bb3fd1116c9"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad784eb701a135080a9593bb3fd1116c9">eagine::memory::shrink</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, const L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gad784eb701a135080a9593bb3fd1116c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks a span by removing a specified count of elements from both sides.  <a href="group__memory.html#gad784eb701a135080a9593bb3fd1116c9">More...</a><br /></td></tr>
<tr class="separator:gad784eb701a135080a9593bb3fd1116c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3e0f08a316739f8d30fc30443879da"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:gaea3e0f08a316739f8d30fc30443879da"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaea3e0f08a316739f8d30fc30443879da">eagine::memory::head</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, const L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gaea3e0f08a316739f8d30fc30443879da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first <code>l</code> elements from the front of a span.  <a href="group__memory.html#gaea3e0f08a316739f8d30fc30443879da">More...</a><br /></td></tr>
<tr class="separator:gaea3e0f08a316739f8d30fc30443879da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81762823c17ec6fe9fed50c39b1b8a3b"><td class="memTemplParams" colspan="2">template&lt;typename Ts , typename Ps , typename Ss , typename Tl , typename Pl , typename Sl &gt; </td></tr>
<tr class="memitem:ga81762823c17ec6fe9fed50c39b1b8a3b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga81762823c17ec6fe9fed50c39b1b8a3b">eagine::memory::head</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt; s, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Tl, Pl, Sl &gt; l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt;</td></tr>
<tr class="memdesc:ga81762823c17ec6fe9fed50c39b1b8a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the head of <code>s</code> l.size() elements long.  <a href="group__memory.html#ga81762823c17ec6fe9fed50c39b1b8a3b">More...</a><br /></td></tr>
<tr class="separator:ga81762823c17ec6fe9fed50c39b1b8a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762c1e676e6009043f6ce26d8fc5adf4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:ga762c1e676e6009043f6ce26d8fc5adf4"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga762c1e676e6009043f6ce26d8fc5adf4">eagine::memory::tail</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, const L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga762c1e676e6009043f6ce26d8fc5adf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last <code>l</code> elements from the back of a span.  <a href="group__memory.html#ga762c1e676e6009043f6ce26d8fc5adf4">More...</a><br /></td></tr>
<tr class="separator:ga762c1e676e6009043f6ce26d8fc5adf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75c41c113994d0167c73f8d10d7ce84"><td class="memTemplParams" colspan="2">template&lt;typename Ts , typename Ps , typename Ss , typename Tl , typename Pl , typename Sl &gt; </td></tr>
<tr class="memitem:gab75c41c113994d0167c73f8d10d7ce84"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gab75c41c113994d0167c73f8d10d7ce84">eagine::memory::tail</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt; s, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Tl, Pl, Sl &gt; l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt;</td></tr>
<tr class="memdesc:gab75c41c113994d0167c73f8d10d7ce84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tail of <code>s</code> l.size() elements long.  <a href="group__memory.html#gab75c41c113994d0167c73f8d10d7ce84">More...</a><br /></td></tr>
<tr class="separator:gab75c41c113994d0167c73f8d10d7ce84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12689a22ab8956b5caf31e3b93b174e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gac12689a22ab8956b5caf31e3b93b174e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac12689a22ab8956b5caf31e3b93b174e">eagine::memory::starts_with</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; with) -&gt; bool</td></tr>
<tr class="memdesc:gac12689a22ab8956b5caf31e3b93b174e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if span <code>spn</code> starts with the content of <code>with</code>.  <a href="group__memory.html#gac12689a22ab8956b5caf31e3b93b174e">More...</a><br /></td></tr>
<tr class="separator:gac12689a22ab8956b5caf31e3b93b174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba766a9aca6f4dddb37dfda8bededa81"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gaba766a9aca6f4dddb37dfda8bededa81"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaba766a9aca6f4dddb37dfda8bededa81">eagine::memory::ends_with</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; with) -&gt; bool</td></tr>
<tr class="memdesc:gaba766a9aca6f4dddb37dfda8bededa81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if span <code>spn</code> ends with the content of <code>with</code>.  <a href="group__memory.html#gaba766a9aca6f4dddb37dfda8bededa81">More...</a><br /></td></tr>
<tr class="separator:gaba766a9aca6f4dddb37dfda8bededa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b3d627fb49ad62d3786f1649754e968"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga0b3d627fb49ad62d3786f1649754e968"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga0b3d627fb49ad62d3786f1649754e968">eagine::memory::strip_prefix</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; prefix) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga0b3d627fb49ad62d3786f1649754e968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the specified <code>prefix</code> from a span.  <a href="group__memory.html#ga0b3d627fb49ad62d3786f1649754e968">More...</a><br /></td></tr>
<tr class="separator:ga0b3d627fb49ad62d3786f1649754e968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9cb27c6eb3c1488a12bb3e98e66976f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gad9cb27c6eb3c1488a12bb3e98e66976f"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad9cb27c6eb3c1488a12bb3e98e66976f">eagine::memory::strip_suffix</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; suffix) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:gad9cb27c6eb3c1488a12bb3e98e66976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the specified <code>suffix</code> from a span.  <a href="group__memory.html#gad9cb27c6eb3c1488a12bb3e98e66976f">More...</a><br /></td></tr>
<tr class="separator:gad9cb27c6eb3c1488a12bb3e98e66976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55fda17a4c0e5657e91b857e27e7334c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga55fda17a4c0e5657e91b857e27e7334c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga55fda17a4c0e5657e91b857e27e7334c">eagine::memory::contains</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) noexcept -&gt; S1</td></tr>
<tr class="memdesc:ga55fda17a4c0e5657e91b857e27e7334c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a span contains the contents of <code>what</code>.  <a href="group__memory.html#ga55fda17a4c0e5657e91b857e27e7334c">More...</a><br /></td></tr>
<tr class="separator:ga55fda17a4c0e5657e91b857e27e7334c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6e37561a171da3f2e04cb619f7759a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga1f6e37561a171da3f2e04cb619f7759a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1f6e37561a171da3f2e04cb619f7759a">eagine::memory::find_position</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; S1 &gt;</td></tr>
<tr class="memdesc:ga1f6e37561a171da3f2e04cb619f7759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the first occurrence of <code>what</code> in a span.  <a href="group__memory.html#ga1f6e37561a171da3f2e04cb619f7759a">More...</a><br /></td></tr>
<tr class="separator:ga1f6e37561a171da3f2e04cb619f7759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c32b6d73a4a3520f0d9bf8a0edc269"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename E &gt; </td></tr>
<tr class="memitem:ga47c32b6d73a4a3520f0d9bf8a0edc269"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga47c32b6d73a4a3520f0d9bf8a0edc269">eagine::memory::find_element</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, const E &amp;what) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; S &gt;</td></tr>
<tr class="memdesc:ga47c32b6d73a4a3520f0d9bf8a0edc269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the first occurrence of <code>what</code> in a span.  <a href="group__memory.html#ga47c32b6d73a4a3520f0d9bf8a0edc269">More...</a><br /></td></tr>
<tr class="separator:ga47c32b6d73a4a3520f0d9bf8a0edc269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b7bfb4380cf2fce5ec639d8ca811edf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename F &gt; </td></tr>
<tr class="memitem:ga4b7bfb4380cf2fce5ec639d8ca811edf"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4b7bfb4380cf2fce5ec639d8ca811edf">eagine::memory::find_element_if</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, F predicate) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; S &gt;</td></tr>
<tr class="memdesc:ga4b7bfb4380cf2fce5ec639d8ca811edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the first element satisfying <code>predicate</code> in a span.  <a href="group__memory.html#ga4b7bfb4380cf2fce5ec639d8ca811edf">More...</a><br /></td></tr>
<tr class="separator:ga4b7bfb4380cf2fce5ec639d8ca811edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cebd0419880739fcd4f4dddec5acd98"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Pos &gt; </td></tr>
<tr class="memitem:ga5cebd0419880739fcd4f4dddec5acd98"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5cebd0419880739fcd4f4dddec5acd98">eagine::memory::skip_to</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Pos pos) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; requires(std::is_convertible_v&lt; Pos, P &gt;)</td></tr>
<tr class="memdesc:ga5cebd0419880739fcd4f4dddec5acd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns.  <a href="group__memory.html#ga5cebd0419880739fcd4f4dddec5acd98">More...</a><br /></td></tr>
<tr class="separator:ga5cebd0419880739fcd4f4dddec5acd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e13b146db46a074794a209d900c0f18"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:ga4e13b146db46a074794a209d900c0f18"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4e13b146db46a074794a209d900c0f18">eagine::memory::skip_until</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga4e13b146db46a074794a209d900c0f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips the elements from the front of a span until <code>predicate</code> is satisfied.  <a href="group__memory.html#ga4e13b146db46a074794a209d900c0f18">More...</a><br /></td></tr>
<tr class="separator:ga4e13b146db46a074794a209d900c0f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae045d336b96731e17dcb00c5b23d8936"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:gae045d336b96731e17dcb00c5b23d8936"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gae045d336b96731e17dcb00c5b23d8936">eagine::memory::take_until</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gae045d336b96731e17dcb00c5b23d8936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the elements from the front of a span until <code>predicate</code> is satisfied.  <a href="group__memory.html#gae045d336b96731e17dcb00c5b23d8936">More...</a><br /></td></tr>
<tr class="separator:gae045d336b96731e17dcb00c5b23d8936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29bd612e60c77ec77c2e780659ae80c5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga29bd612e60c77ec77c2e780659ae80c5"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga29bd612e60c77ec77c2e780659ae80c5">eagine::memory::reverse_find_position</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; S1 &gt;</td></tr>
<tr class="memdesc:ga29bd612e60c77ec77c2e780659ae80c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the last occurrence of <code>what</code> in a span.  <a href="group__memory.html#ga29bd612e60c77ec77c2e780659ae80c5">More...</a><br /></td></tr>
<tr class="separator:ga29bd612e60c77ec77c2e780659ae80c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ef9a335a56af00cc7fb890bb096b3d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga06ef9a335a56af00cc7fb890bb096b3d"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga06ef9a335a56af00cc7fb890bb096b3d">eagine::memory::find</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; where, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga06ef9a335a56af00cc7fb890bb096b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the last occurrence of <code>what</code> in a span.  <a href="group__memory.html#ga06ef9a335a56af00cc7fb890bb096b3d">More...</a><br /></td></tr>
<tr class="separator:ga06ef9a335a56af00cc7fb890bb096b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e85a633cce1ed4bcc6f01c82c891ca3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga5e85a633cce1ed4bcc6f01c82c891ca3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5e85a633cce1ed4bcc6f01c82c891ca3">eagine::memory::slice_before</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga5e85a633cce1ed4bcc6f01c82c891ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span before the first occurrence of <code>what</code>.  <a href="group__memory.html#ga5e85a633cce1ed4bcc6f01c82c891ca3">More...</a><br /></td></tr>
<tr class="separator:ga5e85a633cce1ed4bcc6f01c82c891ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f691f73d98558fdaf208142d91c178"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga45f691f73d98558fdaf208142d91c178"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga45f691f73d98558fdaf208142d91c178">eagine::memory::slice_after</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga45f691f73d98558fdaf208142d91c178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span after the first occurrence of <code>what</code>.  <a href="group__memory.html#ga45f691f73d98558fdaf208142d91c178">More...</a><br /></td></tr>
<tr class="separator:ga45f691f73d98558fdaf208142d91c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f0ed9fc9cd3594fcfaac9f547446530"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga8f0ed9fc9cd3594fcfaac9f547446530"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga8f0ed9fc9cd3594fcfaac9f547446530">eagine::memory::split_by_first</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; std::tuple&lt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&gt;</td></tr>
<tr class="memdesc:ga8f0ed9fc9cd3594fcfaac9f547446530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a span by the first occurrence of <code>what</code> (before and after, what)  <a href="group__memory.html#ga8f0ed9fc9cd3594fcfaac9f547446530">More...</a><br /></td></tr>
<tr class="separator:ga8f0ed9fc9cd3594fcfaac9f547446530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e2fa77c06355a3cb388bf7380830ab"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gac2e2fa77c06355a3cb388bf7380830ab"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac2e2fa77c06355a3cb388bf7380830ab">eagine::memory::slice_before_last</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:gac2e2fa77c06355a3cb388bf7380830ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span before the last occurrence of <code>what</code>.  <a href="group__memory.html#gac2e2fa77c06355a3cb388bf7380830ab">More...</a><br /></td></tr>
<tr class="separator:gac2e2fa77c06355a3cb388bf7380830ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19cc0c35b22633324e1d4b70e0cb410"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gac19cc0c35b22633324e1d4b70e0cb410"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac19cc0c35b22633324e1d4b70e0cb410">eagine::memory::slice_after_last</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:gac19cc0c35b22633324e1d4b70e0cb410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span after the last occurrence of <code>what</code>.  <a href="group__memory.html#gac19cc0c35b22633324e1d4b70e0cb410">More...</a><br /></td></tr>
<tr class="separator:gac19cc0c35b22633324e1d4b70e0cb410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb7c299187ea57add2666ec08e064d3b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gaeb7c299187ea57add2666ec08e064d3b"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaeb7c299187ea57add2666ec08e064d3b">eagine::memory::split_by_last</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; std::tuple&lt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&gt;</td></tr>
<tr class="memdesc:gaeb7c299187ea57add2666ec08e064d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a span by the last occurrence of <code>what</code> (before and after, what)  <a href="group__memory.html#gaeb7c299187ea57add2666ec08e064d3b">More...</a><br /></td></tr>
<tr class="separator:gaeb7c299187ea57add2666ec08e064d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb0904504776afb7f6942be19128069c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename B &gt; </td></tr>
<tr class="memitem:gadb0904504776afb7f6942be19128069c"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gadb0904504776afb7f6942be19128069c">eagine::memory::slice_inside_brackets</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, const B left, const B right) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gadb0904504776afb7f6942be19128069c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span within a pair of brackets.  <a href="group__memory.html#gadb0904504776afb7f6942be19128069c">More...</a><br /></td></tr>
<tr class="separator:gadb0904504776afb7f6942be19128069c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe89faf981965c31cdc287612b0f4b4"><td class="memTemplParams" colspan="2">template&lt;typename TF , typename PF , typename SF , typename TT , typename PT , typename ST &gt; </td></tr>
<tr class="memitem:ga5fe89faf981965c31cdc287612b0f4b4"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5fe89faf981965c31cdc287612b0f4b4">eagine::memory::copy</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TF, PF, SF &gt; from, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TT, PT, ST &gt; to) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TT, PT, ST &gt;</td></tr>
<tr class="memdesc:ga5fe89faf981965c31cdc287612b0f4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from one span to another compatible span.  <a href="group__memory.html#ga5fe89faf981965c31cdc287612b0f4b4">More...</a><br /></td></tr>
<tr class="separator:ga5fe89faf981965c31cdc287612b0f4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec6ddb74681e391ff8df87c82654754"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename V &gt; </td></tr>
<tr class="memitem:ga1ec6ddb74681e391ff8df87c82654754"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1ec6ddb74681e391ff8df87c82654754">eagine::memory::fill</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, const V &amp;v) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga1ec6ddb74681e391ff8df87c82654754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a span with copies of the specified value.  <a href="group__memory.html#ga1ec6ddb74681e391ff8df87c82654754">More...</a><br /></td></tr>
<tr class="separator:ga1ec6ddb74681e391ff8df87c82654754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f187611bb7997b40a64b5800a18c3bf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga8f187611bb7997b40a64b5800a18c3bf"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga8f187611bb7997b40a64b5800a18c3bf">eagine::memory::zero</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; requires(std::is_integral_v&lt; T &gt;||std::is_floating_point_v&lt; T &gt;)</td></tr>
<tr class="memdesc:ga8f187611bb7997b40a64b5800a18c3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a span with zero value of type T.  <a href="group__memory.html#ga8f187611bb7997b40a64b5800a18c3bf">More...</a><br /></td></tr>
<tr class="separator:ga8f187611bb7997b40a64b5800a18c3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fcc53ccd72374acc5d913064e01e8c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga0fcc53ccd72374acc5d913064e01e8c9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga0fcc53ccd72374acc5d913064e01e8c9">eagine::memory::reverse</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga0fcc53ccd72374acc5d913064e01e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the elements in a span.  <a href="group__memory.html#ga0fcc53ccd72374acc5d913064e01e8c9">More...</a><br /></td></tr>
<tr class="separator:ga0fcc53ccd72374acc5d913064e01e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f7c39956697c400992558431e490ac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Transform &gt; </td></tr>
<tr class="memitem:gab0f7c39956697c400992558431e490ac"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gab0f7c39956697c400992558431e490ac">eagine::memory::transform</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Transform function) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gab0f7c39956697c400992558431e490ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the elements of a span with a <code>function</code>.  <a href="group__memory.html#gab0f7c39956697c400992558431e490ac">More...</a><br /></td></tr>
<tr class="separator:gab0f7c39956697c400992558431e490ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a70ad3483da892c69fb46406573938"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Generator &gt; </td></tr>
<tr class="memitem:gae7a70ad3483da892c69fb46406573938"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gae7a70ad3483da892c69fb46406573938">eagine::memory::generate</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Generator gen) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gae7a70ad3483da892c69fb46406573938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a span with elements generated by a generator callable.  <a href="group__memory.html#gae7a70ad3483da892c69fb46406573938">More...</a><br /></td></tr>
<tr class="separator:gae7a70ad3483da892c69fb46406573938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0139802989fce6bb9609b77eb447daa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename RandGen &gt; </td></tr>
<tr class="memitem:gaa0139802989fce6bb9609b77eb447daa"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa0139802989fce6bb9609b77eb447daa">eagine::memory::shuffle</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, RandGen rg) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gaa0139802989fce6bb9609b77eb447daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles the elements of a span.  <a href="group__memory.html#gaa0139802989fce6bb9609b77eb447daa">More...</a><br /></td></tr>
<tr class="separator:gaa0139802989fce6bb9609b77eb447daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad84cf3d7cf242c3f2d6f786668031276"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:gad84cf3d7cf242c3f2d6f786668031276"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad84cf3d7cf242c3f2d6f786668031276">eagine::memory::sort</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gad84cf3d7cf242c3f2d6f786668031276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a span.  <a href="group__memory.html#gad84cf3d7cf242c3f2d6f786668031276">More...</a><br /></td></tr>
<tr class="separator:gad84cf3d7cf242c3f2d6f786668031276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36998dacf1d4c34b889c27d4e55fea2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Compare &gt; </td></tr>
<tr class="memitem:ga36998dacf1d4c34b889c27d4e55fea2d"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga36998dacf1d4c34b889c27d4e55fea2d">eagine::memory::sort</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Compare compare) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga36998dacf1d4c34b889c27d4e55fea2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a span according to <code>compare</code>.  <a href="group__memory.html#ga36998dacf1d4c34b889c27d4e55fea2d">More...</a><br /></td></tr>
<tr class="separator:ga36998dacf1d4c34b889c27d4e55fea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e4a02dfe8ba4eede729d5211f5c3ad6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename I , typename PI , typename SI , typename Compare &gt; </td></tr>
<tr class="memitem:ga2e4a02dfe8ba4eede729d5211f5c3ad6"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga2e4a02dfe8ba4eede729d5211f5c3ad6">eagine::memory::make_index</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; I, PI, SI &gt; idx, Compare compare) -&gt; bool</td></tr>
<tr class="memdesc:ga2e4a02dfe8ba4eede729d5211f5c3ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the index of a span according to <code>compare</code>, into another span.  <a href="group__memory.html#ga2e4a02dfe8ba4eede729d5211f5c3ad6">More...</a><br /></td></tr>
<tr class="separator:ga2e4a02dfe8ba4eede729d5211f5c3ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612ae3ea6058db36a7233a2cc41540fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename I , typename PI , typename SI &gt; </td></tr>
<tr class="memitem:ga612ae3ea6058db36a7233a2cc41540fa"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga612ae3ea6058db36a7233a2cc41540fa">eagine::memory::make_index</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; I, PI, SI &gt; idx) -&gt; bool</td></tr>
<tr class="memdesc:ga612ae3ea6058db36a7233a2cc41540fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the index of a span, into another span.  <a href="group__memory.html#ga612ae3ea6058db36a7233a2cc41540fa">More...</a><br /></td></tr>
<tr class="separator:ga612ae3ea6058db36a7233a2cc41540fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dcb46ff8b2a81e37a599e29c823b54f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga0dcb46ff8b2a81e37a599e29c823b54f"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga0dcb46ff8b2a81e37a599e29c823b54f">eagine::memory::is_sorted</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) -&gt; bool</td></tr>
<tr class="memdesc:ga0dcb46ff8b2a81e37a599e29c823b54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the elements in a span are sorted.  <a href="group__memory.html#ga0dcb46ff8b2a81e37a599e29c823b54f">More...</a><br /></td></tr>
<tr class="separator:ga0dcb46ff8b2a81e37a599e29c823b54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade76316013164eaf7c5c1797ac72835f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Compare &gt; </td></tr>
<tr class="memitem:gade76316013164eaf7c5c1797ac72835f"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gade76316013164eaf7c5c1797ac72835f">eagine::memory::is_sorted</a> (const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Compare compare) -&gt; bool</td></tr>
<tr class="memdesc:gade76316013164eaf7c5c1797ac72835f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the elements in a span are sorted according to <code>compare</code>.  <a href="group__memory.html#gade76316013164eaf7c5c1797ac72835f">More...</a><br /></td></tr>
<tr class="separator:gade76316013164eaf7c5c1797ac72835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d18b460a98d7f056bad04266263422d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Output &gt; </td></tr>
<tr class="memitem:ga0d18b460a98d7f056bad04266263422d"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga0d18b460a98d7f056bad04266263422d">list_to_stream</a> (Output &amp;out, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; s) -&gt; Output &amp;</td></tr>
<tr class="memdesc:ga0d18b460a98d7f056bad04266263422d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for pretty-printing spans as lists into output streams.  <a href="group__memory.html#ga0d18b460a98d7f056bad04266263422d">More...</a><br /></td></tr>
<tr class="separator:ga0d18b460a98d7f056bad04266263422d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1b0b92acd6ef6c1e9bb9f1a1d932d29b">read_from_stream</a> (Input &amp;in, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; s) -&gt; auto &amp;</td></tr>
<tr class="memdesc:ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for raw-reading spans from output streams.  <a href="group__memory.html#ga1b0b92acd6ef6c1e9bb9f1a1d932d29b">More...</a><br /></td></tr>
<tr class="separator:ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a3c93302a74b4aca24c81e63a8ccb39"><td class="memTemplParams" colspan="2">template&lt;typename Output , typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga1a3c93302a74b4aca24c81e63a8ccb39"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1a3c93302a74b4aca24c81e63a8ccb39">write_to_stream</a> (Output &amp;out, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; s) -&gt; auto &amp;</td></tr>
<tr class="memdesc:ga1a3c93302a74b4aca24c81e63a8ccb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for raw-reading spans into output streams.  <a href="group__memory.html#ga1a3c93302a74b4aca24c81e63a8ccb39">More...</a><br /></td></tr>
<tr class="separator:ga1a3c93302a74b4aca24c81e63a8ccb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ffe63d4017edcc7395b803241b60c0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga68ffe63d4017edcc7395b803241b60c0"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga68ffe63d4017edcc7395b803241b60c0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; s) -&gt; std::ostream &amp;requires(!std::is_same_v&lt; std::remove_const_t&lt; T &gt;, char &gt;)</td></tr>
<tr class="memdesc:ga68ffe63d4017edcc7395b803241b60c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for printing generic element spans into output streams.  <a href="group__memory.html#ga68ffe63d4017edcc7395b803241b60c0">More...</a><br /></td></tr>
<tr class="separator:ga68ffe63d4017edcc7395b803241b60c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca12a64a5abf6726aaa2546668241cb9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:gaca12a64a5abf6726aaa2546668241cb9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaca12a64a5abf6726aaa2546668241cb9">make_span_getter</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;i, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; spn)</td></tr>
<tr class="memdesc:gaca12a64a5abf6726aaa2546668241cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a callable that returns consecutive span elements starting at i.  <a href="group__memory.html#gaca12a64a5abf6726aaa2546668241cb9">More...</a><br /></td></tr>
<tr class="separator:gaca12a64a5abf6726aaa2546668241cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca68d4b2b222bfaea0303ac261efa54"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Transform &gt; </td></tr>
<tr class="memitem:ga7ca68d4b2b222bfaea0303ac261efa54"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga7ca68d4b2b222bfaea0303ac261efa54">make_span_getter</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;i, const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; spn, const Transform transform)</td></tr>
<tr class="memdesc:ga7ca68d4b2b222bfaea0303ac261efa54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a callable getting consecutive, transformed span elements starting at i.  <a href="group__memory.html#ga7ca68d4b2b222bfaea0303ac261efa54">More...</a><br /></td></tr>
<tr class="separator:ga7ca68d4b2b222bfaea0303ac261efa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e1777a757360856d19eb7ead9dc7cbd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga6e1777a757360856d19eb7ead9dc7cbd"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6e1777a757360856d19eb7ead9dc7cbd">make_span_putter</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;i, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; spn)</td></tr>
<tr class="memdesc:ga6e1777a757360856d19eb7ead9dc7cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a callable setting consecutive elements of a span starting at i.  <a href="group__memory.html#ga6e1777a757360856d19eb7ead9dc7cbd">More...</a><br /></td></tr>
<tr class="separator:ga6e1777a757360856d19eb7ead9dc7cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac618307bf991c77102ee6b4748c03419"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Transform &gt; </td></tr>
<tr class="memitem:gac618307bf991c77102ee6b4748c03419"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac618307bf991c77102ee6b4748c03419">make_span_putter</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;i, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; spn, Transform transform)</td></tr>
<tr class="memdesc:gac618307bf991c77102ee6b4748c03419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a callable setting consecutive elements of a span starting at i.  <a href="group__memory.html#gac618307bf991c77102ee6b4748c03419">More...</a><br /></td></tr>
<tr class="separator:gac618307bf991c77102ee6b4748c03419"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5dd5ce1a14209336eb031bc930d736f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dd5ce1a14209336eb031bc930d736f4">&#9670;&nbsp;</a></span>block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">eagine::memory::block</a> = typedef <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for non-const byte memory span. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1memory_1_1buffer.html" title="Reallocatable owning byte buffer.">buffer</a> </dd></dl>

</div>
</div>
<a id="ga9abe6f67096b87cac1c3116a66379971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9abe6f67096b87cac1c3116a66379971">&#9670;&nbsp;</a></span>const_block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">eagine::memory::const_block</a> = typedef <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for const byte memory span. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1memory_1_1buffer.html" title="Reallocatable owning byte buffer.">buffer</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad27c0cdcfa69797e43615d234ce753f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad27c0cdcfa69797e43615d234ce753f6">&#9670;&nbsp;</a></span>absolute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::absolute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, T*, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to span using a native pointer type. </p>
<dl class="section see"><dt>See also</dt><dd>relative </dd></dl>

</div>
</div>
<a id="gad1cc5174f2f1a431a7c85f3f3f8b7081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1cc5174f2f1a431a7c85f3f3f8b7081">&#9670;&nbsp;</a></span>accommodate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename B , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::accommodate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; B, P, S &gt;&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>tid</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, rebind_pointer_t&lt;P, T&gt;, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a span, rebinding the element type (typically from basic_block). </p>
<dl class="section see"><dt>See also</dt><dd>as_bytes </dd>
<dd>
<a class="el" href="group__embedding.html#gaa4d95a4c9285f038fa9e81662d2bf7e1" title="Converts the embedded resource block to a const span of characters.">as_chars</a> </dd></dl>

</div>
</div>
<a id="gac6a58b3dadbde62e6c31b11bc73eeacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a58b3dadbde62e6c31b11bc73eeacc">&#9670;&nbsp;</a></span>align_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsConst&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::align_down </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt;IsConst&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a memory address down to the specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximum byte offset that can be applied to the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8af2919ea33b999d3226a85d77c8bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8af2919ea33b999d3226a85d77c8bc8a">&#9670;&nbsp;</a></span>align_down_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::align_down_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="group__type__utils.html#ga7cfd5092e7be96db6a5c1a28f61203ab">span_align_of</a>&lt;T&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>max</em> = <code><a class="el" href="group__type__utils.html#ga5da29a349a0c54ae40001ec06b9ab247">span_size_of</a>&lt;T&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a memory address down to the required alignment of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximum byte offset that can be applied to the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3bf6d48a299d6cb9ccc091bf4e3fa84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bf6d48a299d6cb9ccc091bf4e3fa84a">&#9670;&nbsp;</a></span>align_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsConst&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::align_up </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt;IsConst&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a memory address up to the specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximum byte offset that can be applied to the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac88809b30e4be19991c30dbf9fbb3f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac88809b30e4be19991c30dbf9fbb3f33">&#9670;&nbsp;</a></span>align_up_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::align_up_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="group__type__utils.html#ga7cfd5092e7be96db6a5c1a28f61203ab">span_align_of</a>&lt;T&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>max</em> = <code><a class="el" href="group__type__utils.html#ga5da29a349a0c54ae40001ec06b9ab247">span_size_of</a>&lt;T&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a memory address up to the required alignment of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximum byte offset that can be applied to the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d5b348a30a24217bcf763dfab47e19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d5b348a30a24217bcf763dfab47e19b">&#9670;&nbsp;</a></span>as_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::as_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt;std::is_const_v&lt;T&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a span into a basic_block. </p>
<dl class="section see"><dt>See also</dt><dd>accommodate </dd>
<dd>
<a class="el" href="group__embedding.html#gaa4d95a4c9285f038fa9e81662d2bf7e1" title="Converts the embedded resource block to a const span of characters.">as_chars</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1program__arg.html#a9af6d8ef0e07262587bfff1ab38191e8">eagine::program_arg::block()</a>, <a class="el" href="classeagine_1_1basic__string__path.html#a5dd30bbded70679b8bcfd158942417e8">eagine::basic_string_path::block()</a>, <a class="el" href="classeagine_1_1memory_1_1aligned__block.html#aebd5d1a770dc32745e32739673160aa4">eagine::memory::aligned_block&lt; Size &gt;::get()</a>, and <a class="el" href="structeagine_1_1serializer__data__sink.html#a44d3347850fd09b58642b4c015818f27">eagine::serializer_data_sink::write()</a>.</p>

</div>
</div>
<a id="ga74ac2f99ccac9b9fab354f56bff6ddf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ac2f99ccac9b9fab354f56bff6ddf6">&#9670;&nbsp;</a></span>as_chars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::as_chars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a>&#160;</td>
          <td class="paramname"><em>blk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a block into a span of characters. </p>
<dl class="section see"><dt>See also</dt><dd>accommodate </dd>
<dd>
as_bytes </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__embedding.html#gaa4d95a4c9285f038fa9e81662d2bf7e1">eagine::embedded_resource::as_chars()</a>.</p>

</div>
</div>
<a id="ga49a137e2cf62bd132b54ca445a5d93c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a137e2cf62bd132b54ca445a5d93c5">&#9670;&nbsp;</a></span>as_chars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::as_chars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a>&#160;</td>
          <td class="paramname"><em>blk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a block into a span of characters. </p>
<dl class="section see"><dt>See also</dt><dd>accommodate </dd>
<dd>
as_bytes </dd></dl>

</div>
</div>
<a id="ga55fda17a4c0e5657e91b857e27e7334c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55fda17a4c0e5657e91b857e27e7334c">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; S1 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if a span contains the contents of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>starts_with </dd>
<dd>
ends_with </dd></dl>

</div>
</div>
<a id="ga5fe89faf981965c31cdc287612b0f4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fe89faf981965c31cdc287612b0f4b4">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TF , typename PF , typename SF , typename TT , typename PT , typename ST &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TF, PF, SF &gt;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TT, PT, ST &gt;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;TT, PT, ST&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from one span to another compatible span. </p>
<dl class="section see"><dt>See also</dt><dd>fill </dd>
<dd>
zero </dd>
<dd>
generate </dd></dl>

</div>
</div>
<a id="ga617108b1fef48ea67b32f98c346b9b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga617108b1fef48ea67b32f98c346b9b8e">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of source block to destination block. </p>
<dl class="section see"><dt>See also</dt><dd>const_block </dd>
<dd>
block </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gadb27620c9e29d7365a08a5686f0c3bba">eagine::memory::copy_into()</a>, <a class="el" href="classeagine_1_1istream__data__source.html#a22edf38bd47751a9b0d687505264f68c">eagine::istream_data_source::pop()</a>, <a class="el" href="classeagine_1_1block__data__sink.html#a2bb8e4b9374e70a3a62ace1e07b0c40b">eagine::block_data_sink::replace_with()</a>, and <a class="el" href="classeagine_1_1block__data__sink.html#ae765c1f94fb303f39e667fd60ac82208">eagine::block_data_sink::write()</a>.</p>

</div>
</div>
<a id="gadb27620c9e29d7365a08a5686f0c3bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb27620c9e29d7365a08a5686f0c3bba">&#9670;&nbsp;</a></span>copy_into()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::copy_into </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1buffer.html">buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of source block to destination buffer. </p>
<dl class="section see"><dt>See also</dt><dd>const_block </dd>
<dd>
<a class="el" href="classeagine_1_1memory_1_1buffer.html" title="Reallocatable owning byte buffer.">buffer</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1embedded__resource.html#adfbab3d4e3ebfd0d967572da6362d473">eagine::embedded_resource::unpack()</a>.</p>

</div>
</div>
<a id="gaba766a9aca6f4dddb37dfda8bededa81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba766a9aca6f4dddb37dfda8bededa81">&#9670;&nbsp;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>with</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if span <code>spn</code> ends with the content of <code>with</code>. </p>
<dl class="section see"><dt>See also</dt><dd>starts_with </dd>
<dd>
contains </dd>
<dd>
strip_suffix </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1program__arg.html#a59ef16beb23bc0dffb31be9567613046">eagine::program_arg::ends_with()</a>, and <a class="el" href="group__memory.html#gad9cb27c6eb3c1488a12bb3e98e66976f">eagine::memory::strip_suffix()</a>.</p>

</div>
</div>
<a id="ga05e741e072a75182869ff2c0cfbb83be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05e741e072a75182869ff2c0cfbb83be">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of extract for spans. Returns the first element,. </p>
<dl class="section pre"><dt>Precondition</dt><dd>spn.size() &gt;= 1 </dd></dl>

</div>
</div>
<a id="ga1ec6ddb74681e391ff8df87c82654754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ec6ddb74681e391ff8df87c82654754">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a span with copies of the specified value. </p>
<dl class="section see"><dt>See also</dt><dd>copy </dd>
<dd>
zero </dd>
<dd>
generate </dd></dl>

</div>
</div>
<a id="ga06ef9a335a56af00cc7fb890bb096b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06ef9a335a56af00cc7fb890bb096b3d">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the last occurrence of <code>what</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find_element </dd>
<dd>
find_element_if </dd>
<dd>
find_position </dd></dl>

<p class="reference">Referenced by <a class="el" href="structeagine_1_1valtree_1_1compound__interface.html#aa0eaa92c6dcecc5ad999061e4688105c">eagine::valtree::compound_interface::find()</a>.</p>

</div>
</div>
<a id="ga47c32b6d73a4a3520f0d9bf8a0edc269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47c32b6d73a4a3520f0d9bf8a0edc269">&#9670;&nbsp;</a></span>find_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::find_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the first occurrence of <code>what</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find </dd>
<dd>
find_position </dd>
<dd>
find_element_if </dd>
<dd>
reverse_find_position </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gadb0904504776afb7f6942be19128069c">eagine::memory::slice_inside_brackets()</a>, and <a class="el" href="group__string__utils.html#ga584bf8f3e3165b490f1c97b787c51e00">eagine::substitute_variables_into()</a>.</p>

</div>
</div>
<a id="ga4b7bfb4380cf2fce5ec639d8ca811edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b7bfb4380cf2fce5ec639d8ca811edf">&#9670;&nbsp;</a></span>find_element_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::find_element_if </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the first element satisfying <code>predicate</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find </dd>
<dd>
find_position </dd>
<dd>
find_element </dd>
<dd>
reverse_find_position </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga4e13b146db46a074794a209d900c0f18">eagine::memory::skip_until()</a>, and <a class="el" href="group__memory.html#gae045d336b96731e17dcb00c5b23d8936">eagine::memory::take_until()</a>.</p>

</div>
</div>
<a id="ga1f6e37561a171da3f2e04cb619f7759a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f6e37561a171da3f2e04cb619f7759a">&#9670;&nbsp;</a></span>find_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::find_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the first occurrence of <code>what</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find </dd>
<dd>
find_element </dd>
<dd>
find_element_if </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga06ef9a335a56af00cc7fb890bb096b3d">eagine::memory::find()</a>, <a class="el" href="group__type__utils.html#ga3a82d71f37fbdf764e2800d4316ea352">eagine::memory::for_each_delimited()</a>, <a class="el" href="group__memory.html#ga45f691f73d98558fdaf208142d91c178">eagine::memory::slice_after()</a>, <a class="el" href="group__memory.html#ga5e85a633cce1ed4bcc6f01c82c891ca3">eagine::memory::slice_before()</a>, <a class="el" href="group__memory.html#ga8f0ed9fc9cd3594fcfaac9f547446530">eagine::memory::split_by_first()</a>, and <a class="el" href="group__string__utils.html#gab8f18bf99de54fb077806ac7c0352fb1">eagine::substitute_variable_into()</a>.</p>

</div>
</div>
<a id="gae7a70ad3483da892c69fb46406573938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a70ad3483da892c69fb46406573938">&#9670;&nbsp;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a span with elements generated by a generator callable. </p>
<dl class="section see"><dt>See also</dt><dd>copy </dd>
<dd>
fill </dd>
<dd>
zero </dd></dl>

</div>
</div>
<a id="gaea3e0f08a316739f8d30fc30443879da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea3e0f08a316739f8d30fc30443879da">&#9670;&nbsp;</a></span>head() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::head </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first <code>l</code> elements from the front of a span. </p>
<dl class="section see"><dt>See also</dt><dd>tail </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1block__data__sink.html#aa83c1a3382952caa03e7d4c4a76ead23">eagine::block_data_sink::done()</a>, <a class="el" href="classeagine_1_1valtree_1_1compound.html#af7b9efbc3eb0fcfb01275b687aaf6c35">eagine::valtree::compound::fetch_values()</a>, <a class="el" href="classeagine_1_1istream__data__source.html#a22edf38bd47751a9b0d687505264f68c">eagine::istream_data_source::pop()</a>, <a class="el" href="classeagine_1_1valtree_1_1compound.html#af6a49d3d022e63245d205366216f301a">eagine::valtree::compound::select_values()</a>, <a class="el" href="group__string__utils.html#gab8f18bf99de54fb077806ac7c0352fb1">eagine::substitute_variable_into()</a>, <a class="el" href="group__string__utils.html#ga584bf8f3e3165b490f1c97b787c51e00">eagine::substitute_variables_into()</a>, <a class="el" href="classeagine_1_1block__data__source.html#aba7541ee6bcb5af481db35d5f03f4479">eagine::block_data_source::top()</a>, <a class="el" href="classeagine_1_1istream__data__source.html#a6590177a69f8e68e73514f0dbbedb21c">eagine::istream_data_source::top()</a>, and <a class="el" href="classeagine_1_1block__data__sink.html#ae765c1f94fb303f39e667fd60ac82208">eagine::block_data_sink::write()</a>.</p>

</div>
</div>
<a id="ga81762823c17ec6fe9fed50c39b1b8a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81762823c17ec6fe9fed50c39b1b8a3b">&#9670;&nbsp;</a></span>head() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ts , typename Ps , typename Ss , typename Tl , typename Pl , typename Sl &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::head </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Tl, Pl, Sl &gt;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;Ts, Ps, Ss&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the head of <code>s</code> l.size() elements long. </p>
<dl class="section see"><dt>See also</dt><dd>tail </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__type__utils.html#ga3a82d71f37fbdf764e2800d4316ea352">eagine::memory::for_each_delimited()</a>, <a class="el" href="group__memory.html#ga5e85a633cce1ed4bcc6f01c82c891ca3">eagine::memory::slice_before()</a>, <a class="el" href="group__memory.html#gac2e2fa77c06355a3cb388bf7380830ab">eagine::memory::slice_before_last()</a>, <a class="el" href="group__memory.html#gadb0904504776afb7f6942be19128069c">eagine::memory::slice_inside_brackets()</a>, <a class="el" href="group__memory.html#gaf94ba8cc892b237b54a760d3c84a14e5">eagine::memory::snip()</a>, <a class="el" href="group__memory.html#ga8f0ed9fc9cd3594fcfaac9f547446530">eagine::memory::split_by_first()</a>, <a class="el" href="group__memory.html#gaeb7c299187ea57add2666ec08e064d3b">eagine::memory::split_by_last()</a>, <a class="el" href="group__memory.html#gac12689a22ab8956b5caf31e3b93b174e">eagine::memory::starts_with()</a>, and <a class="el" href="group__memory.html#gae045d336b96731e17dcb00c5b23d8936">eagine::memory::take_until()</a>.</p>

</div>
</div>
<a id="ga0dcb46ff8b2a81e37a599e29c823b54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dcb46ff8b2a81e37a599e29c823b54f">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::is_sorted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if the elements in a span are sorted. </p>
<dl class="section see"><dt>See also</dt><dd>sort </dd>
<dd>
shuffle </dd>
<dd>
make_index </dd></dl>

</div>
</div>
<a id="gade76316013164eaf7c5c1797ac72835f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade76316013164eaf7c5c1797ac72835f">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::is_sorted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if the elements in a span are sorted according to <code>compare</code>. </p>
<dl class="section see"><dt>See also</dt><dd>sort </dd>
<dd>
shuffle </dd>
<dd>
make_index </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga0dcb46ff8b2a81e37a599e29c823b54f">eagine::memory::is_sorted()</a>.</p>

</div>
</div>
<a id="ga0d18b460a98d7f056bad04266263422d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d18b460a98d7f056bad04266263422d">&#9670;&nbsp;</a></span>list_to_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto list_to_stream </td>
          <td>(</td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Output&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for pretty-printing spans as lists into output streams. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga1a3c93302a74b4aca24c81e63a8ccb39" title="Helper function for raw-reading spans into output streams.">write_to_stream</a> </dd></dl>

</div>
</div>
<a id="ga612ae3ea6058db36a7233a2cc41540fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga612ae3ea6058db36a7233a2cc41540fa">&#9670;&nbsp;</a></span>make_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename I , typename PI , typename SI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::make_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; I, PI, SI &gt;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the index of a span, into another span. </p>
<dl class="section see"><dt>See also</dt><dd>is_sorted </dd>
<dd>
sort </dd>
<dd>
shuffle </dd></dl>

</div>
</div>
<a id="ga2e4a02dfe8ba4eede729d5211f5c3ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e4a02dfe8ba4eede729d5211f5c3ad6">&#9670;&nbsp;</a></span>make_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename I , typename PI , typename SI , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::make_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; I, PI, SI &gt;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the index of a span according to <code>compare</code>, into another span. </p>
<dl class="section see"><dt>See also</dt><dd>is_sorted </dd>
<dd>
sort </dd>
<dd>
shuffle </dd></dl>

</div>
</div>
<a id="gaca12a64a5abf6726aaa2546668241cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca12a64a5abf6726aaa2546668241cb9">&#9670;&nbsp;</a></span>make_span_getter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto make_span_getter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a callable that returns consecutive span elements starting at i. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga6e1777a757360856d19eb7ead9dc7cbd" title="Makes a callable setting consecutive elements of a span starting at i.">make_span_putter</a></dd></dl>
<p>The constructed callable object does not take any arguments in the call operator and returns optional values of T. </p>

</div>
</div>
<a id="ga7ca68d4b2b222bfaea0303ac261efa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca68d4b2b222bfaea0303ac261efa54">&#9670;&nbsp;</a></span>make_span_getter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto make_span_getter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Transform&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a callable getting consecutive, transformed span elements starting at i. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga6e1777a757360856d19eb7ead9dc7cbd" title="Makes a callable setting consecutive elements of a span starting at i.">make_span_putter</a></dd></dl>
<p>The constructed callable object does not take any arguments in the call operator and returns the result of the transform function. The transform function takes a single optional value of T. </p>

</div>
</div>
<a id="ga6e1777a757360856d19eb7ead9dc7cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e1777a757360856d19eb7ead9dc7cbd">&#9670;&nbsp;</a></span>make_span_putter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto make_span_putter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a callable setting consecutive elements of a span starting at i. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#gaca12a64a5abf6726aaa2546668241cb9" title="Makes a callable that returns consecutive span elements starting at i.">make_span_getter</a></dd></dl>
<p>The constructed callable takes a single value explicitly convertible to T. </p>

</div>
</div>
<a id="gac618307bf991c77102ee6b4748c03419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac618307bf991c77102ee6b4748c03419">&#9670;&nbsp;</a></span>make_span_putter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto make_span_putter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a callable setting consecutive elements of a span starting at i. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>transformation operation to be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#gaca12a64a5abf6726aaa2546668241cb9" title="Makes a callable that returns consecutive span elements starting at i.">make_span_getter</a></dd></dl>
<p>The constructed callable takes a single value explicitly convertible to the argument of the transform function. </p>

</div>
</div>
<a id="ga68ffe63d4017edcc7395b803241b60c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ffe63d4017edcc7395b803241b60c0">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ostream&amp; requires(!std::is_same_v&lt;std::remove_const_t&lt;T&gt;, char&gt;) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for printing generic element spans into output streams. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga0d18b460a98d7f056bad04266263422d" title="Helper function for pretty-printing spans as lists into output streams.">list_to_stream</a> </dd></dl>

</div>
</div>
<a id="ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b0b92acd6ef6c1e9bb9f1a1d932d29b">&#9670;&nbsp;</a></span>read_from_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto read_from_stream </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; auto&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for raw-reading spans from output streams. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga1a3c93302a74b4aca24c81e63a8ccb39" title="Helper function for raw-reading spans into output streams.">write_to_stream</a> </dd></dl>

</div>
</div>
<a id="gadd2bd8629c6e69e1b9ee40ad72e61876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd2bd8629c6e69e1b9ee40ad72e61876">&#9670;&nbsp;</a></span>relative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::relative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt;T, std::make_signed_t&lt;S&gt;&gt;, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to span using an offset pointer type. </p>
<dl class="section see"><dt>See also</dt><dd>absolute </dd></dl>

</div>
</div>
<a id="ga0fcc53ccd72374acc5d913064e01e8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fcc53ccd72374acc5d913064e01e8c9">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the elements in a span. </p>
<dl class="section see"><dt>See also</dt><dd>transform </dd>
<dd>
shuffle </dd>
<dd>
sort </dd></dl>

</div>
</div>
<a id="ga29bd612e60c77ec77c2e780659ae80c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29bd612e60c77ec77c2e780659ae80c5">&#9670;&nbsp;</a></span>reverse_find_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::reverse_find_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the last occurrence of <code>what</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find_position </dd>
<dd>
find_position_if </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gac19cc0c35b22633324e1d4b70e0cb410">eagine::memory::slice_after_last()</a>, <a class="el" href="group__memory.html#gac2e2fa77c06355a3cb388bf7380830ab">eagine::memory::slice_before_last()</a>, and <a class="el" href="group__memory.html#gaeb7c299187ea57add2666ec08e064d3b">eagine::memory::split_by_last()</a>.</p>

</div>
</div>
<a id="gad784eb701a135080a9593bb3fd1116c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad784eb701a135080a9593bb3fd1116c9">&#9670;&nbsp;</a></span>shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::shrink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrinks a span by removing a specified count of elements from both sides. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
tail </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gadb0904504776afb7f6942be19128069c">eagine::memory::slice_inside_brackets()</a>.</p>

</div>
</div>
<a id="gaa0139802989fce6bb9609b77eb447daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0139802989fce6bb9609b77eb447daa">&#9670;&nbsp;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename RandGen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandGen&#160;</td>
          <td class="paramname"><em>rg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuffles the elements of a span. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1reverse.html" title="Adapter reversing the iteration of elements in a Range.">reverse</a> </dd>
<dd>
sort </dd>
<dd>
is_sorted </dd></dl>

</div>
</div>
<a id="ga8eb44c79939a13fac26cb489d52ef660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eb44c79939a13fac26cb489d52ef660">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::skip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips a specified count of elements from the front of a span. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
tail </dd>
<dd>
slice </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga55fda17a4c0e5657e91b857e27e7334c">eagine::memory::contains()</a>, <a class="el" href="group__memory.html#ga06ef9a335a56af00cc7fb890bb096b3d">eagine::memory::find()</a>, <a class="el" href="group__memory.html#ga1f6e37561a171da3f2e04cb619f7759a">eagine::memory::find_position()</a>, <a class="el" href="group__type__utils.html#ga3a82d71f37fbdf764e2800d4316ea352">eagine::memory::for_each_delimited()</a>, <a class="el" href="classeagine_1_1block__data__sink.html#ae2e2441d94fc755efd26163c99212498">eagine::block_data_sink::free()</a>, <a class="el" href="classeagine_1_1istream__data__source.html#a22edf38bd47751a9b0d687505264f68c">eagine::istream_data_source::pop()</a>, <a class="el" href="group__memory.html#ga29bd612e60c77ec77c2e780659ae80c5">eagine::memory::reverse_find_position()</a>, <a class="el" href="group__memory.html#gad784eb701a135080a9593bb3fd1116c9">eagine::memory::shrink()</a>, <a class="el" href="group__memory.html#ga4e13b146db46a074794a209d900c0f18">eagine::memory::skip_until()</a>, <a class="el" href="group__memory.html#ga45f691f73d98558fdaf208142d91c178">eagine::memory::slice_after()</a>, <a class="el" href="group__memory.html#gac19cc0c35b22633324e1d4b70e0cb410">eagine::memory::slice_after_last()</a>, <a class="el" href="group__memory.html#gadb0904504776afb7f6942be19128069c">eagine::memory::slice_inside_brackets()</a>, <a class="el" href="group__memory.html#ga8f0ed9fc9cd3594fcfaac9f547446530">eagine::memory::split_by_first()</a>, <a class="el" href="group__memory.html#gaeb7c299187ea57add2666ec08e064d3b">eagine::memory::split_by_last()</a>, <a class="el" href="group__memory.html#ga0b3d627fb49ad62d3786f1649754e968">eagine::memory::strip_prefix()</a>, <a class="el" href="group__string__utils.html#gab8f18bf99de54fb077806ac7c0352fb1">eagine::substitute_variable_into()</a>, <a class="el" href="group__string__utils.html#ga584bf8f3e3165b490f1c97b787c51e00">eagine::substitute_variables_into()</a>, <a class="el" href="classeagine_1_1memory_1_1basic__split__span.html#a4ef4a6233167955d6d9476d3947d371a">eagine::memory::basic_split_span&lt; ValueType, Pointer, SizeType &gt;::tail()</a>, <a class="el" href="group__memory.html#ga762c1e676e6009043f6ce26d8fc5adf4">eagine::memory::tail()</a>, <a class="el" href="classeagine_1_1block__data__source.html#aba7541ee6bcb5af481db35d5f03f4479">eagine::block_data_source::top()</a>, and <a class="el" href="classeagine_1_1istream__data__source.html#a6590177a69f8e68e73514f0dbbedb21c">eagine::istream_data_source::top()</a>.</p>

</div>
</div>
<a id="ga5cebd0419880739fcd4f4dddec5acd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cebd0419880739fcd4f4dddec5acd98">&#9670;&nbsp;</a></span>skip_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Pos &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::skip_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pos&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; requires(std::is_convertible_v&lt;Pos, P&gt;) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns. </p>
<dl class="section see"><dt>See also</dt><dd>skip_until </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>spn.begin() &lt;= pos &amp;&amp; pos &lt;= spn.end() </dd></dl>

</div>
</div>
<a id="ga4e13b146db46a074794a209d900c0f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e13b146db46a074794a209d900c0f18">&#9670;&nbsp;</a></span>skip_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::skip_until </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips the elements from the front of a span until <code>predicate</code> is satisfied. </p>
<dl class="section see"><dt>See also</dt><dd>take_until </dd>
<dd>
skip_to </dd></dl>

</div>
</div>
<a id="ga924678aab0e9e49147b5cd038ab68754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga924678aab0e9e49147b5cd038ab68754">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename I , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span starting at specified index with specified length. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
tail </dd>
<dd>
skip </dd>
<dd>
snip </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__type__utils.html#gaae35e9ec5c2a721f696b50d75990ea8a">eagine::memory::for_each_chunk()</a>, <a class="el" href="group__memory.html#gaea3e0f08a316739f8d30fc30443879da">eagine::memory::head()</a>, and <a class="el" href="group__memory.html#ga8eb44c79939a13fac26cb489d52ef660">eagine::memory::skip()</a>.</p>

</div>
</div>
<a id="ga45f691f73d98558fdaf208142d91c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45f691f73d98558fdaf208142d91c178">&#9670;&nbsp;</a></span>slice_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span after the first occurrence of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>slice_before </dd>
<dd>
find_position </dd></dl>

</div>
</div>
<a id="gac19cc0c35b22633324e1d4b70e0cb410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19cc0c35b22633324e1d4b70e0cb410">&#9670;&nbsp;</a></span>slice_after_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_after_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span after the last occurrence of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>reverse_find_position </dd></dl>

</div>
</div>
<a id="ga5e85a633cce1ed4bcc6f01c82c891ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e85a633cce1ed4bcc6f01c82c891ca3">&#9670;&nbsp;</a></span>slice_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span before the first occurrence of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>slice_after </dd>
<dd>
find_position </dd></dl>

</div>
</div>
<a id="gac2e2fa77c06355a3cb388bf7380830ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e2fa77c06355a3cb388bf7380830ab">&#9670;&nbsp;</a></span>slice_before_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_before_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span before the last occurrence of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>reverse_find_position </dd></dl>

</div>
</div>
<a id="gadb0904504776afb7f6942be19128069c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb0904504776afb7f6942be19128069c">&#9670;&nbsp;</a></span>slice_inside_brackets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_inside_brackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span within a pair of brackets. </p>
<dl class="section see"><dt>See also</dt><dd>find_element </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__string__utils.html#ga584bf8f3e3165b490f1c97b787c51e00">eagine::substitute_variables_into()</a>.</p>

</div>
</div>
<a id="gaf94ba8cc892b237b54a760d3c84a14e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf94ba8cc892b237b54a760d3c84a14e5">&#9670;&nbsp;</a></span>snip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::snip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Snips a specified count of elements from the back of a span. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
tail </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gad784eb701a135080a9593bb3fd1116c9">eagine::memory::shrink()</a>, and <a class="el" href="group__memory.html#gad9cb27c6eb3c1488a12bb3e98e66976f">eagine::memory::strip_suffix()</a>.</p>

</div>
</div>
<a id="gad84cf3d7cf242c3f2d6f786668031276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad84cf3d7cf242c3f2d6f786668031276">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a span. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1reverse.html" title="Adapter reversing the iteration of elements in a Range.">reverse</a> </dd>
<dd>
shuffle </dd>
<dd>
is_sorted </dd>
<dd>
make_index </dd></dl>

</div>
</div>
<a id="ga36998dacf1d4c34b889c27d4e55fea2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36998dacf1d4c34b889c27d4e55fea2d">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a span according to <code>compare</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1reverse.html" title="Adapter reversing the iteration of elements in a Range.">reverse</a> </dd>
<dd>
shuffle </dd>
<dd>
is_sorted </dd>
<dd>
make_index </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga2e4a02dfe8ba4eede729d5211f5c3ad6">eagine::memory::make_index()</a>, and <a class="el" href="group__memory.html#gad84cf3d7cf242c3f2d6f786668031276">eagine::memory::sort()</a>.</p>

</div>
</div>
<a id="ga8f0ed9fc9cd3594fcfaac9f547446530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f0ed9fc9cd3594fcfaac9f547446530">&#9670;&nbsp;</a></span>split_by_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::split_by_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a span by the first occurrence of <code>what</code> (before and after, what) </p>
<dl class="section see"><dt>See also</dt><dd>find_position </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1url.html#a533ab109ccdb7224e0d9527f21d8391f">eagine::url::argument()</a>, and <a class="el" href="classeagine_1_1url.html#acbc06e0c71359d2c3c980d0b18a767af">eagine::url::query()</a>.</p>

</div>
</div>
<a id="gaeb7c299187ea57add2666ec08e064d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb7c299187ea57add2666ec08e064d3b">&#9670;&nbsp;</a></span>split_by_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::split_by_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a span by the last occurrence of <code>what</code> (before and after, what) </p>
<dl class="section see"><dt>See also</dt><dd>reverse_find_position </dd></dl>

</div>
</div>
<a id="gac12689a22ab8956b5caf31e3b93b174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12689a22ab8956b5caf31e3b93b174e">&#9670;&nbsp;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>with</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if span <code>spn</code> starts with the content of <code>with</code>. </p>
<dl class="section see"><dt>See also</dt><dd>ends_with </dd>
<dd>
contains </dd>
<dd>
strip_prefix </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga55fda17a4c0e5657e91b857e27e7334c">eagine::memory::contains()</a>, <a class="el" href="group__memory.html#ga1f6e37561a171da3f2e04cb619f7759a">eagine::memory::find_position()</a>, <a class="el" href="classeagine_1_1valtree_1_1compound.html#a1a6812b3774f32b6cab8f53fb4c3eb5b">eagine::valtree::compound::has_value()</a>, <a class="el" href="group__memory.html#ga29bd612e60c77ec77c2e780659ae80c5">eagine::memory::reverse_find_position()</a>, <a class="el" href="classeagine_1_1program__arg.html#af7bf4d64b406ece47b7d1c5df863106b">eagine::program_arg::starts_with()</a>, and <a class="el" href="group__memory.html#ga0b3d627fb49ad62d3786f1649754e968">eagine::memory::strip_prefix()</a>.</p>

</div>
</div>
<a id="ga0b3d627fb49ad62d3786f1649754e968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b3d627fb49ad62d3786f1649754e968">&#9670;&nbsp;</a></span>strip_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::strip_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strips the specified <code>prefix</code> from a span. </p>
<dl class="section see"><dt>See also</dt><dd>starts_with </dd>
<dd>
strip_suffix </dd></dl>

</div>
</div>
<a id="gad9cb27c6eb3c1488a12bb3e98e66976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9cb27c6eb3c1488a12bb3e98e66976f">&#9670;&nbsp;</a></span>strip_suffix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::strip_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strips the specified <code>suffix</code> from a span. </p>
<dl class="section see"><dt>See also</dt><dd>ends_with </dd>
<dd>
strip_prefix </dd></dl>

</div>
</div>
<a id="ga762c1e676e6009043f6ce26d8fc5adf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762c1e676e6009043f6ce26d8fc5adf4">&#9670;&nbsp;</a></span>tail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::tail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last <code>l</code> elements from the back of a span. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

</div>
</div>
<a id="gab75c41c113994d0167c73f8d10d7ce84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab75c41c113994d0167c73f8d10d7ce84">&#9670;&nbsp;</a></span>tail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ts , typename Ps , typename Ss , typename Tl , typename Pl , typename Sl &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::tail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Tl, Pl, Sl &gt;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;Ts, Ps, Ss&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tail of <code>s</code> l.size() elements long. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gaba766a9aca6f4dddb37dfda8bededa81">eagine::memory::ends_with()</a>.</p>

</div>
</div>
<a id="gae045d336b96731e17dcb00c5b23d8936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae045d336b96731e17dcb00c5b23d8936">&#9670;&nbsp;</a></span>take_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::take_until </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes the elements from the front of a span until <code>predicate</code> is satisfied. </p>
<dl class="section see"><dt>See also</dt><dd>skip_until </dd></dl>

</div>
</div>
<a id="gab0f7c39956697c400992558431e490ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f7c39956697c400992558431e490ac">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the elements of a span with a <code>function</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1reverse.html" title="Adapter reversing the iteration of elements in a Range.">reverse</a> </dd>
<dd>
shuffle </dd>
<dd>
sort </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gab0f7c39956697c400992558431e490ac">eagine::memory::transform()</a>.</p>

</div>
</div>
<a id="ga1a3c93302a74b4aca24c81e63a8ccb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a3c93302a74b4aca24c81e63a8ccb39">&#9670;&nbsp;</a></span>write_to_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output , typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto write_to_stream </td>
          <td>(</td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; auto&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for raw-reading spans into output streams. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga1b0b92acd6ef6c1e9bb9f1a1d932d29b" title="Helper function for raw-reading spans from output streams.">read_from_stream</a> </dd>
<dd>
<a class="el" href="group__memory.html#ga0d18b460a98d7f056bad04266263422d" title="Helper function for pretty-printing spans as lists into output streams.">list_to_stream</a> </dd></dl>

</div>
</div>
<a id="ga8f187611bb7997b40a64b5800a18c3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f187611bb7997b40a64b5800a18c3bf">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; requires(
    std::is_integral_v&lt;T&gt; || std::is_floating_point_v&lt;T&gt;) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a span with zero value of type T. </p>
<dl class="section see"><dt>See also</dt><dd>copy </dd>
<dd>
fill </dd>
<dd>
generate </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1timeout.html#afde4e1f4a62b4d621c69c6b858ec19b9">eagine::timeout::timeout()</a>, <a class="el" href="classeagine_1_1math_1_1bezier__curves.html#a78fb610bd27a627e291437f95d00d3fc">eagine::math::bezier_curves&lt; Type, Parameter, Order &gt;::position01()</a>, <a class="el" href="classeagine_1_1timeout.html#a4a42f03d6038d40f86799462eb5cd733">eagine::timeout::reset()</a>, and <a class="el" href="classeagine_1_1math_1_1bezier__curves.html#afe1c9d51571a7e8e3cf66caa5b923793">eagine::math::bezier_curves&lt; Type, Parameter, Order &gt;::wrap()</a>.</p>

</div>
</div>
</div><!-- contents -->
<br/>
<div id="eagine-bottom">
<em>Copyright &copy; 2015-2022</em> <strong>Mat Chochlk</strong>.<br/>
&lt;<a href="mailto:chochlik@gmail.com">chochlik -at -gmail.com</a>&gt;<br/>
Documentation generated on Wed May 18 2022 by <a href="http://www.doxygen.org/index.html">Doxygen</a> (version 1.9.1).
</div> <!-- eagine-bottom -->
</div> <!-- eagine-content -->
</div> <!-- eagine-frame -->
</body>
</html>
